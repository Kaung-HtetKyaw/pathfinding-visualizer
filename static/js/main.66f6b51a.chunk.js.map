{"version":3,"sources":["PathFinding/visualizer/Node/index.js","utils/utils.js","PathFinding/algorithms/utils.js","PathFinding/DataStructure/BinaryHeap.js","PathFinding/algorithms/dijkstra.js","PathFinding/algorithms/a-star.js","PathFinding/algorithms/heuristics.js","PathFinding/algorithms/GBFS.js","PathFinding/algorithms/index.js","PathFinding/algorithms/BFS.js","PathFinding/algorithms/DFS.js","maze/recursive-division.js","maze/index.js","maze/randomMaze.js","maze/stairCase.js","maze/randomWeight.js","utils/constants.js","common/components/Header.js","images/triangle-right.svg","images/circle.svg","images/weight.svg","common/components/Glossary.js","PathFinding/visualizer/index.js","app/App.js","app/theme.js","index.js"],"names":["Node","y","isStart","name","isEnd","isWall","isWeight","x","isClosed","start","end","grid","visited","isGridDirty","isStartSelected","isEndSelected","handleMouseUp","isMousePressed","handleMouseDown","handleMouseEnter","toggleSpecialNode","relocateStart","relocateEnd","ref","createRef","useState","extraClassName","animationClassName","useEffect","current","classList","remove","style","margin","width","height","display","onMouseDown","onMouseUp","onMouseEnter","onClick","id","className","React","memo","prefixNumberWithZero","num","convertXYToName","generateGrid","row","column","weighted","outerArr","xLength","innerArr","push","generateNode","setCosts","value","closed","parent","f","g","h","weight","inputGrid","length","node","this","setCostsToNeighbours","getNeighbourNodes","currentNode","walls","isDFS","dirs","result","i","dir","direction","Math","abs","xGrid","neighbour","undefined","diagonal","unshift","randomInteger","min","max","floor","random","getFinalPath","startNode","cur","reverse","curX","curY","BinaryHeap","getScore","content","bubbleUp","endNode","pop","sinkDown","nodeValue","index","indexOf","rightIndex","leftIndex","rightNode","rightNodeValue","leftNode","leftNodeValue","temp","parentIndex","priorityQueue","manhattan_h","getShortestNode","openList","shortest","ALGORITHMS","Dijkstra","about","algorithm","weights","visitedList","closedList","numNodes","size","path","console","log","visitedNodes","closedNodes","neighbours","neighboursLength","currentG","reorderNode","Astar","heuristics","pow","BFS","Object","keys","shift","neighbourLength","GBFS","currentH","DFS","wallsOrder","addInnerWalls","minX","maxX","minY","maxY","gate","randomNumber","hole","addHWall","minxX","addVWall","MAZES","Random","rowLength","colLength","randomNum","order","Stair","currentX","currentY","Recursive_Division","startXY","endXY","j","addOuterWalls","ent","entrance","addEntrance","WeightMaze","SPEED","Fast","Normal","Slow","Header","setAlgorithm","maze","setMaze","speed","setSpeed","animating","visualize","generateMaze","clearBoard","maxW","bg","py","color","fontSize","mt","isDisabled","onChange","e","target","defaultValue","colorScheme","map","el","variant","_hover","backgroundColor","specialNodes","img","startNodeimg","endNodeImg","weightNodeImg","otherNodes","Glossary","my","px","boxSize","src","as","fontWeight","mr","textAlign","fontStyle","Visualizer","forceUpdate","useForceUpdate","setGrid","setWalls","setWeights","setIsMousePressed","isWPressed","setIsWPressed","setIsStartSelected","setIsEndSelected","setIsGridDirty","setStart","setEnd","setAnimating","document","addEventListener","handleWDown","removeEventListener","handleWUp","key","col","toggleSelectSpecialNode","v","toggleWall","toggleWeight","event","drawPath","pathLength","setTimeout","getElementById","add","newGrid","animate","flexDir","justifyContent","alignItems","minH","animateWalls","cursor","startNodeImg","rowIndex","nodeIndex","App","theme","extendTheme","config","initialColorMode","useSystemColorMode","RootApp","ReactDOM","render"],"mappings":"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","file":"static/js/main.66f6b51a.chunk.js","sourcesContent":["import React, { useEffect, createRef, useState } from \"react\";\n\nimport \"./node.css\";\n\nconst Node = ({\n  y,\n  name,\n  isStart,\n  isEnd,\n  isWall,\n  isWeight,\n  isClosed,\n  x,\n  start,\n  end,\n  grid,\n  visited,\n  isGridDirty,\n  isStartSelected,\n  isEndSelected,\n  isMousePressed,\n  handleMouseUp,\n  handleMouseDown,\n  handleMouseEnter,\n  toggleSpecialNode,\n  relocateStart,\n  relocateEnd,\n}) => {\n  const ref = createRef();\n  let [debouncedDirty, setDebouncedDirty] = useState(false);\n\n  let extraClassName = isEnd\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isWeight\n    ? \"node-weight\"\n    : \"\";\n  let [animationClassName, setAnimationClassName] = useState(\"\");\n\n  // useEffect(() => {\n  //   if (!isGridDirty) {\n  //     setAnimationClassName(\"\");\n  //   }\n  //   if (isGridDirty && (isStartPressed || isEndPressed)) {\n  //     if (isInShortest !== undefined) {\n  //       setAnimationClassName(\"node-shortest-path-no-ani\");\n  //       return;\n  //     }\n  //     if (isInVisited !== undefined) {\n  //       setAnimationClassName(\"node-visited-no-ani\");\n  //       return;\n  //     }\n  //     setAnimationClassName(\"\");\n  //   }\n  // }, [isInShortest, isInVisited]);\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.classList.remove(\"node-visited\");\n      ref.current.classList.remove(\"node-visited-no-ani\");\n      ref.current.classList.remove(\"node-shortest-path\");\n      ref.current.classList.remove(\"node-shortest-path-no-ani\");\n      ref.current.classList.remove(\"node-weight-visited\");\n    }\n  }, [start, end, isGridDirty, visited, grid]);\n\n  useEffect(() => {\n    if (!isWall && ref.current) {\n      ref.current.classList.remove(\"node-wall\");\n    }\n  }, [isWall]);\n\n  const onNodeClick = () => {\n    if (isStart || isEnd) {\n      toggleSpecialNode(isStart, isEnd);\n    } else {\n      if (isStartSelected) {\n        relocateStart(x, y);\n      }\n      if (isEndSelected) {\n        relocateEnd(x, y);\n      }\n    }\n  };\n\n  return (\n    <div\n      style={{\n        margin: 0,\n        width: \"25px\",\n        height: \"25px\",\n        display: \"inline-block\",\n      }}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseEnter={handleMouseEnter}\n      onClick={onNodeClick}\n    >\n      <div\n        ref={ref}\n        id={`node-${x}-${y}`}\n        className={`node ${extraClassName} ${animationClassName}`}\n      ></div>\n    </div>\n  );\n};\n\nexport default React.memo(Node);\n","export const prefixNumberWithZero = (num) => {\n  return num < 10 ? `0${num}` : num;\n};\n\nexport const convertXYToName = (x, y) => {\n  return `${prefixNumberWithZero(x)}${prefixNumberWithZero(y)}`;\n};\n\nexport const isStart = (x, y, start) => start.x === x && start.y === y;\nexport const isEnd = (x, y, end) => end.x === x && end.y === y;\n","// normalize 2D array to 2D with nodes returned from normalizeNode\nimport { convertXYToName } from \"../../utils/utils\";\nexport function generateGrid(row, column, start, end, weighted = false) {\n  let outerArr = [];\n\n  for (let x = 0; x < row; x++) {\n    let xLength = column;\n    let innerArr = [];\n    for (let y = 0; y < xLength; y++) {\n      innerArr.push(generateNode(1, x, y, start, end));\n    }\n    outerArr.push(innerArr);\n  }\n  // set weights\n  if (weighted) setCosts(outerArr, weighted);\n\n  return outerArr;\n}\n\nexport function generateNode(value, x, y, start, end) {\n  return {\n    x,\n    y,\n    visited: false,\n    closed: false,\n    value: value,\n    parent: null,\n    f: 0,\n    g: 0,\n    h: 0,\n    name: convertXYToName(x, y),\n    weight: 0,\n  };\n}\n\n// set the costs of all nodes to their respective neighbours\nexport function setCosts(inputGrid, weighted = false) {\n  let length = inputGrid.length;\n  for (let x = 0; x < length; x++) {\n    let xLength = inputGrid[x].length;\n\n    for (let y = 0; y < xLength; y++) {\n      let node = inputGrid[x][y];\n      this.setCostsToNeighbours(inputGrid, node, weighted);\n    }\n  }\n}\n\n// set the cost of a node to their neighbour\n// 1, if not weighted,i.e, uniform movement costs\n// random num between 1 and 5, if weighted\nexport function setCostsToNeighbours(grid, currentNode, weighted = false) {\n  if (currentNode.value === 0) {\n    return;\n  }\n  // get neighbours\n  let neighbours = this.getNeighbourNodes(grid, currentNode);\n  let neighbourLength = neighbours.length;\n  // for each neighbour\n  // if neighbour has [currentNode.name] as key in weights, add [neighbour.name]=that weight to currentNode weights\n  // if not, generate random num and add [neighbour.name]=random num\n  for (let i = 0; i < neighbourLength; i++) {\n    let neighbour = neighbours[i];\n\n    // if not weighted, set uniform movement cost\n    if (!weighted) {\n      currentNode.weights[neighbour.name] = 1;\n    } else {\n      // if weighted\n      let weightToCur = neighbour.weights[currentNode.name];\n      // if weighted and neighbour already has cost\n      if (weightToCur) {\n        currentNode.weights[neighbour.name] = weightToCur;\n      } else {\n        // weighted but neighbour doesnt have cost\n        currentNode.weights[neighbour.name] = this.randomInteger(1, 5);\n      }\n    }\n  }\n}\n\nexport function getNeighbourNodes(grid, currentNode, walls, isDFS = false) {\n  let { x, y } = currentNode;\n  let dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    // [-1, 1],\n    // [1, 1],\n    // [1, -1],\n    // [-1, -1],\n  ];\n  let result = [];\n  // get valid non-wall nodes\n  for (let i = 0; i < dirs.length; i++) {\n    let dir = dirs[i];\n    let direction = Math.abs(dir[0] + dir[1]);\n    let xGrid = grid[x + dir[0]];\n    let neighbour = xGrid ? xGrid[y + dir[1]] : undefined;\n\n    if (neighbour && !walls[neighbour.name]) {\n      // if the neighbour is diagonal and unvisited, add extra 0.414\n      if (direction === 2) {\n        neighbour.diagonal = true;\n      }\n      if (isDFS) {\n        result.unshift(neighbour);\n      } else {\n        result.push(neighbour);\n      }\n    }\n  }\n\n  // if (grid[x - 1] && grid[x - 1][y] && !grid[x - 1][y].isWall) {\n  //   result.push(grid[x - 1][y]);\n  // }\n  // if (grid[x + 1] && grid[x + 1][y] && !grid[x + 1][y].isWall) {\n  //   result.push(grid[x + 1][y]);\n  // }\n  // if (grid[x][y - 1] && grid[x][y - 1] && !grid[x][y - 1].isWall) {\n  //   result.push(grid[x][y - 1]);\n  // }\n  // if (grid[x][y + 1] && grid[x][y + 1] && !grid[x][y + 1].isWall) {\n  //   result.push(grid[x][y + 1]);\n  // }\n  return result;\n}\n\nexport function randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// will normally return []\n// but, i need low time complexity so i return object, cuz it's O(1) for accessing the node by name\n// downside of this is losing insertion order\n// but i mimic the insertion order by adding index property to each node\nexport function getFinalPath(node, grid, start) {\n  let result = [];\n\n  let startNode = grid[start.x][start.y];\n\n  let cur = node;\n  while (cur.parent) {\n    result.push(cur);\n\n    let { x, y } = cur.parent;\n    cur = grid[x][y];\n  }\n  result.push(startNode);\n\n  return result.reverse();\n}\n\nexport function isEnd(currentNode, end) {\n  let { x: curX, y: curY } = currentNode;\n  let { x, y } = end;\n  return curX === x && curY === y;\n}\n\nexport const resetNodeIfDirty = (node, prevVisited, curVisited) => {\n  const { name } = node;\n  //reset if not visited for cur search yet, but visited last search\n  let isInPrev = prevVisited[name] !== undefined;\n  let isInCur = curVisited[name] !== undefined;\n  if ((isInPrev && !isInCur) || (!isInPrev && !isInCur)) {\n    node.g = 0;\n    node.f = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n  return node;\n};\n","// this the modified version of binary heap implementation from eloquent javascript book\n// you can see the original version here: https://eloquentjavascript.net/1st_edition/appendix2.html\n\nexport default class BinaryHeap {\n  constructor(getScore) {\n    this.content = [];\n    // instead of hard-coding getter for node's value, we will receive as an argument\n    //! But whenever we need node's value, we will call this function like getScore(node)\n    //! instead of hard-coding like node.value\n    this.getScore = getScore;\n  }\n  push(node) {\n    // add new element to the end of array\n    this.content.push(node);\n    // let it bubble up\n    this.bubbleUp(this.content.length - 1);\n  }\n  pop() {\n    let result = this.content[0];\n\n    // get last node and replace it with first node\n    let endNode = this.content.pop(); // this is Array.prototype.pop, not this class method pop\n\n    // let it sinkDown\n    if (this.content.length > 0) {\n      this.content[0] = endNode;\n      this.sinkDown(0);\n    }\n\n    return result;\n  }\n\n  getLastItem() {\n    return this.content[this.content.length - 1];\n  }\n\n  remove(node) {\n    let length = this.content.length;\n    let nodeValue = this.getScore(node);\n    // to remove a node, we must find item that's equal to node's value\n    for (let i = 0; i < length; i++) {\n      // continue to next item if node value is not equal to current one\n      if (nodeValue !== this.getScore(this.content[i])) continue;\n\n      // get reference to the last item\n      let endNode = this.content.pop(); // this pop() is Array.prototype.pop\n\n      // if node is the last item, we r done\n      if (i === length - 1) break;\n      // replace the node with the last node\n      this.content[i] = endNode;\n      // let it bubble up or sinkdown to reorder the node and then break out the loop, we r done\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n  size() {\n    return this.content.length;\n  }\n  reorderNode(node) {\n    let index = this.content.indexOf(node);\n    this.bubbleUp(index);\n    this.sinkDown(index);\n  }\n  sinkDown(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n    let length = this.content.length;\n\n    while (true) {\n      let rightIndex = (index + 1) * 2;\n      let leftIndex = rightIndex - 1;\n      let rightNode = this.content[rightIndex];\n      let rightNodeValue = this.getScore(rightNode);\n      let leftNode = this.content[leftIndex];\n      let leftNodeValue = this.getScore(leftNode);\n      let temp = null;\n\n      // if left child exists\n      if (leftIndex < length) {\n        if (leftNodeValue < nodeValue) temp = leftIndex;\n      }\n      // if right child exists\n      if (rightIndex < length) {\n        if (rightNodeValue < (temp === null ? nodeValue : leftNodeValue))\n          temp = rightIndex;\n      }\n      // if temp is null, node is smaller than both of its children\n      if (temp === null) break;\n      // swap\n      this.content[index] = this.content[temp];\n      this.content[temp] = node;\n      index = temp;\n    }\n  }\n\n  bubbleUp(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n\n    // except root node\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      let parent = this.content[parentIndex];\n      // node value is greater than parent value, break out the loop\n      if (nodeValue >= this.getScore(parent)) break;\n      // swap node and it's parent\n      this.content[parentIndex] = node;\n      this.content[index] = parent;\n      index = parentIndex;\n    }\n  }\n}\n","import { isEnd, getFinalPath, getNeighbourNodes } from \"./utils\";\nimport BinaryHeap from \"../DataStructure/BinaryHeap\";\n\n// following implementation is mixed with a little bit of UI logic\n// visitedNodesOrder and shortestNodesOrder are for UI purposes\n// see original impelementation at my repo: https://github.com/Kaung-HtetKyaw/Algorithm-Javascript-Implementation\n// this implementation uses Binary Heap for Priority Queue\nlet priorityQueue = new BinaryHeap((x) => x?.g); // binary heap as priority queue\n\n// will reset the node if the grid is used more than once\nexport default function dijkstra(grid, start, end, walls = {}, weights = {}) {\n  let startNode = grid[start.x][start.y];\n\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n  // push to the queue,  add to visited list\n\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n\n      // for first time visiting or current g is smaller than the previous one\n      if (!visited || currentG < neighbour.g) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.g = currentG;\n\n        if (!visited) {\n          neighbour.visited = true;\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n  console.log(\"exhausted\");\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n\n// function addToVisitedList(visitedList, node) {\n//   visitedList[node.name] = { node, order: visitedNodesCount };\n//   visitedNodesCount++;\n// }\n","import BinaryHeap from \"../DataStructure/BinaryHeap\";\nimport { getFinalPath, getNeighbourNodes, isEnd } from \"./utils\";\n\nconst priorityQueue = new BinaryHeap((x) => x?.f);\nexport default function a_star(\n  grid,\n  start,\n  end,\n  walls = {},\n  weights = {},\n  heuristics = manhattan_h\n) {\n  let startNode = grid[start.x][start.y];\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  // push to the queue,  add to visited list\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n    // console.log(\"current: \", { x: currentNode.x, y: currentNode.y });\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n      // for first time visiting, there is no previous g so current g will be the best\n      if (!visited || currentG < neighbour.g) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.h = neighbour.h || Math.pow(heuristics(neighbour, end), 1.1);\n        neighbour.g = currentG;\n        neighbour.f = neighbour.g + neighbour.h;\n\n        if (!visited) {\n          neighbour.visited = true;\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n\n  return { path: [], visitedNodes: visitedList, closedNodes: closedList };\n}\n\nfunction manhattan_h(node, end) {\n  let D = 1;\n  let d1 = Math.abs(node.x - end.x);\n  let d2 = Math.abs(node.y - end.y);\n  return D * (d1 + d2);\n}\n","export function manhattan_h(node, end) {\n  let D = 1;\n  let d1 = Math.abs(node.x - end.x);\n  let d2 = Math.abs(node.y - end.y);\n  return D * (d1 + d2);\n}\n","import { manhattan_h } from \"./heuristics\";\nimport { isEnd, getFinalPath, getNeighbourNodes } from \"./utils\";\n\n// object is used for openList because when removing an item , it's time complexity is O(1)\nexport default function greedy_best_first_search(\n  grid,\n  start,\n  end,\n  walls,\n  weights,\n  heuristics = manhattan_h\n) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = { [startNode.name]: startNode };\n  startNode.visited = true;\n  visitedList.push(startNode);\n\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (Object.keys(openList).length > 0) {\n    // get the shortest node from open list\n    let currentNode = getShortestNode(openList);\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return { path, closedNodes: closedList, visitedNodes: visitedList };\n    }\n\n    // remove curretNode from openlist and set the flag to closed cuz currentNode is already considered\n    delete openList[currentNode.name];\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      let currentH =\n        heuristics(neighbour, end) + (weights[neighbour.name] ? 15 : 0);\n\n      // for first time visiting, there is no previous g so current g will be the best\n      if (!neighbour.visited || currentH < neighbour.h) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.h = currentH;\n\n        if (!neighbour.visited) {\n          neighbour.visited = true;\n          openList[neighbour.name] = neighbour;\n          visitedList.push(neighbour);\n        }\n      }\n    }\n  }\n  // return empty array if there is no path\n  return { path: [], closedNodes: closedList, visitedNodes: visitedList };\n}\n\nfunction getShortestNode(openList) {\n  let shortest = null;\n  for (let node in openList) {\n    let isCurrentShortest =\n      shortest === null || openList[node].h < openList[shortest].h;\n    if (isCurrentShortest) {\n      shortest = node;\n    }\n  }\n  return openList[shortest];\n}\n","import dijkstra from \"./dijkstra\";\nimport a_star from \"./a-star\";\nimport BFS from \"./BFS\";\nimport GBFS from \"./GBFS\";\nimport DFS from \"./DFS\";\n\nconst ALGORITHMS = {\n  Dijkstra: {\n    name: \"Dijkstra\",\n    about: \"blah blah\",\n    algorithm: dijkstra,\n    weighted: true,\n    shortest: true,\n  },\n  Astar: {\n    name: \"A*\",\n    about: \"blah blah\",\n    algorithm: a_star,\n    weighted: true,\n    shortest: true,\n  },\n  BFS: {\n    name: \"Breadth First Search\",\n    about: \"blah blah\",\n    algorithm: BFS,\n    weighted: false,\n    shortest: true,\n  },\n  GBFS: {\n    name: \"Greedy Best First Search\",\n    about: \"blah blah\",\n    algorithm: GBFS,\n    weighted: true,\n    shortest: false,\n  },\n  DFS: {\n    name: \"Depth First Search\",\n    about: \"blah blah\",\n    algorithm: DFS,\n    weighted: false,\n    shortest: false,\n  },\n};\n\nexport default ALGORITHMS;\n","import { getFinalPath, getNeighbourNodes } from \"./utils\";\n\nexport default function breadth_first_search(grid, start, end, walls) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = [startNode];\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (Object.keys(openList).length > 0) {\n    // get the first item\n    let currentNode = openList[0];\n    closedList.push(currentNode);\n    numNodes++;\n    // reach end\n    if (currentNode.x === end.x && currentNode.y === end.y) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n    // remove it from list\n    openList.shift();\n\n    currentNode.closed = true;\n\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighbourLength = neighbours.length;\n\n    for (let x = 0; x < neighbourLength; x++) {\n      let neighbour = neighbours[x];\n\n      // if neighbour is already considered or wall, continue to next neighbour\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // if the neighbour is visited very first time\n      if (!neighbour.visited) {\n        neighbour.visited = true;\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        openList.push(neighbour);\n        visitedList.push(neighbour);\n      }\n    }\n  }\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n","import { getFinalPath, getNeighbourNodes } from \"./utils\";\n\nexport default function depth_first_search(grid, start, end, walls) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = [startNode];\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (Object.keys(openList).length > 0) {\n    // get the first item\n    let currentNode = openList.pop();\n\n    currentNode.closed = true;\n    closedList.push(currentNode);\n\n    currentNode.visited = true;\n    visitedList.push(currentNode);\n\n    numNodes++;\n    // reach end\n    if (currentNode.x === end.x && currentNode.y === end.y) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    let neighbours = getNeighbourNodes(grid, currentNode, walls, true);\n    let neighbourLength = neighbours.length;\n\n    for (let x = 0; x < neighbourLength; x++) {\n      let neighbour = neighbours[x];\n\n      // if neighbour is already considered or wall, continue to next neighbour\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // if the neighbour is visited very first time\n      if (!neighbour.visited) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        openList.push(neighbour);\n      }\n    }\n  }\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n","import { isStart, isEnd } from \"../utils/utils\";\n\nlet walls = {};\nlet wallsOrder = [];\nlet width, height;\nlet start, end;\n\nexport default function recursive_division(grid, startXY, endXY) {\n  height = grid.length;\n  width = grid[0].length;\n  start = startXY;\n  end = endXY;\n  addOuterWalls(grid);\n  let ent = addEntrance(grid);\n  addInnerWalls(grid, true, 1, height - 2, 1, width - 2, ent);\n  return { walls, order: wallsOrder };\n}\n\nfunction addOuterWalls(grid) {\n  for (let i = 0; i < height; i++) {\n    if (i == 0 || i == height - 1) {\n      for (let j = 0; j < width; j++) {\n        if (isStart(i, j, start) || isEnd(i, j, end)) return;\n        grid[i][j].isWall = true;\n        walls[grid[i][j].name] = true;\n        wallsOrder.push(grid[i][j]);\n      }\n    } else {\n      if (!isStart(i, 0, start) && !isEnd(i, 0, end)) {\n        grid[i][0].isWall = true;\n        walls[grid[i][0].name] = true;\n        wallsOrder.push(grid[i][0]);\n      }\n\n      if (!isStart(i, width - 1, start) && !isEnd(i, width - 1, end)) {\n        grid[i][width - 1].isWall = true;\n        walls[grid[i][width - 1].name] = true;\n        wallsOrder.push(grid[i][width - 1]);\n      }\n    }\n  }\n}\n\nfunction addEntrance(grid) {\n  let x = randomNumber(1, grid.length - 1);\n  grid[grid.length - 1][x].entrance = true;\n  return x;\n}\n\nfunction addInnerWalls(grid, h, minX, maxX, minY, maxY, gate) {\n  if (h) {\n    if (maxX - minX < 2) {\n      return;\n    }\n\n    let x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n    addHWall(grid, minY, maxY, x);\n\n    addInnerWalls(grid, false, minX, x - 1, minY, maxY, gate);\n    addInnerWalls(grid, false, x + 1, maxX, minY, maxY, gate);\n  } else {\n    if (maxY - minY < 2) {\n      return;\n    }\n\n    let y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n    addVWall(grid, minX, maxX, y);\n\n    addInnerWalls(grid, true, minX, maxX, minY, y - 1, gate);\n    addInnerWalls(grid, true, minX, maxX, y + 1, maxY, gate);\n  }\n}\n\nfunction addHWall(grid, minY, maxY, y) {\n  let hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n\n  for (let i = minY; i <= maxY; i++) {\n    if (isStart(y, i, start) || isEnd(y, i, end)) return;\n    if (i === hole) grid[y][i].isWall = false;\n    else {\n      grid[y][i].isWall = true;\n      walls[grid[y][i].name] = true;\n      wallsOrder.push(grid[y][i]);\n    }\n  }\n}\n\nfunction addVWall(grid, minxX, maxY, x) {\n  let hole = Math.floor(randomNumber(minxX, maxY) / 2) * 2 + 1;\n\n  for (let i = minxX; i <= maxY; i++) {\n    if (isStart(i, x, start) || isEnd(i, x, end)) return;\n    if (i === hole) grid[i][x].isWall = false;\n    else {\n      grid[i][x].isWall = true;\n      walls[grid[i][x].name] = true;\n      wallsOrder.push(grid[i][x]);\n    }\n  }\n}\n\nfunction randomNumber(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import randomMaze from \"./randomMaze\";\nimport recursive_division from \"./recursive-division\";\nimport stairCase from \"./stairCase\";\nimport randomWeightMaze from \"./randomWeight\";\n\nconst MAZES = {\n  Random: {\n    name: \"Basic Random Maze\",\n    algorithm: randomMaze,\n    about: \"blah blah\",\n  },\n  Stair: {\n    algorithm: stairCase,\n    name: \"Simple Stair Pattern\",\n    about: \"blah blah\",\n  },\n  Recursive_Division: {\n    name: \"Recursive Division\",\n    algorithm: recursive_division,\n    about: \"blah blah\",\n  },\n  WeightMaze: {\n    name: \"Basic Weight Maze\",\n    algorithm: randomWeightMaze,\n    about: \"blah blah\",\n  },\n};\n\nexport default MAZES;\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (randomNum) {\n        node.isWall = false;\n      } else {\n        node.isWall = true;\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","import { isStart, isEnd } from \"../utils/utils\";\n\nexport default function stairCase(grid = [[]], start, end) {\n  let height = grid.length;\n\n  let width = grid[0].length;\n  let currentX = grid.length - 1;\n  let currentY = 0;\n  let walls = {};\n  let wallsOrder = [];\n\n  while (currentX > 0 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  while (currentX < height - 2 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX++;\n    currentY++;\n  }\n  while (currentX > 0 && currentY < width - 1) {\n    let currentNode = grid[currentX][currentY];\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  return { walls, order: wallsOrder };\n}\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomWeightMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (!randomNum) {\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","export const SPEED = {\n  Fast: 15,\n  Normal: 25,\n  Slow: 40,\n};\n","import React from \"react\";\nimport {\n  Container,\n  Box,\n  HStack,\n  VStack,\n  Stack,\n  Heading,\n  Select,\n  Button,\n} from \"@chakra-ui/react\";\nimport ALGORITHMS from \"../../PathFinding/algorithms\";\nimport MAZES from \"../../maze\";\nimport { SPEED } from \"../../utils/constants\";\n\nconst Header = ({\n  algorithm = \"Dijkstra\",\n  setAlgorithm,\n  maze = \"Random\",\n  setMaze,\n  speed,\n  setSpeed,\n  animating,\n  visualize,\n  generateMaze,\n  clearBoard,\n}) => {\n  return (\n    <Container maxW=\"100%\" bg=\"#34495E\" py=\"6\">\n      <Box>\n        <Heading color=\"white\" fontSize=\"2xl\">\n          Pathfinding Visualizer\n        </Heading>\n      </Box>\n      <Box mt={3}>\n        <Stack direction={[\"column\", \"column\", \"row\"]}>\n          <HStack>\n            <Box>\n              <Select\n                isDisabled={animating}\n                onChange={(e) => setAlgorithm(e.target.value)}\n                width=\"120px\"\n                defaultValue={algorithm}\n                colorScheme=\"teal\"\n                color=\"white\"\n                fontSize=\"13px\"\n              >\n                {Object.keys(ALGORITHMS).map((el) => (\n                  <option\n                    style={{ color: \"black\", fontSize: \"15px\" }}\n                    key={el}\n                    value={el}\n                  >\n                    {ALGORITHMS[el].name}\n                  </option>\n                ))}\n              </Select>\n            </Box>\n            <Select\n              isDisabled={animating}\n              onChange={(e) => setMaze(e.target.value)}\n              width=\"170px\"\n              defaultValue={maze}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(MAZES).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {MAZES[el].name}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Select\n              isDisabled={animating}\n              onChange={(e) => setSpeed(e.target.value)}\n              width=\"170px\"\n              defaultValue={speed}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(SPEED).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {el}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => visualize()}\n              colorScheme=\"teal\"\n              fontSize=\"sm\"\n            >\n              Visualize {algorithm}\n            </Button>\n            <Button\n              isDisabled={animating}\n              onClick={() => generateMaze()}\n              colorScheme=\"blue\"\n              fontSize=\"sm\"\n            >\n              Generate Maze\n            </Button>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => clearBoard()}\n              fontSize=\"sm\"\n              variant=\"ghost\"\n              color=\"white\"\n              _hover={{\n                color: \"#34495E\",\n                backgroundColor: \"white\",\n              }}\n            >\n              Clear Board\n            </Button>\n          </HStack>\n        </Stack>\n      </Box>\n    </Container>\n  );\n};\n\nexport default Header;\n","export default __webpack_public_path__ + \"static/media/triangle-right.c7b52e1e.svg\";","export default __webpack_public_path__ + \"static/media/circle.a538beda.svg\";","export default __webpack_public_path__ + \"static/media/weight.2e4bdffd.svg\";","import React from \"react\";\nimport {\n  Container,\n  Heading,\n  Image,\n  Box,\n  HStack,\n  Flex,\n  Text,\n} from \"@chakra-ui/react\";\nimport startNodeimg from \"../../images/triangle-right.svg\";\nimport endNodeImg from \"../../images/circle.svg\";\nimport weightNodeImg from \"../../images/weight.svg\";\nimport ALGORITHMS from \"../../PathFinding/algorithms\";\n\nconst specialNodes = [\n  { name: \"Start Node\", img: startNodeimg },\n  { name: \"End Node\", img: endNodeImg },\n  { name: \"Weight Node\", img: weightNodeImg },\n];\n\nconst otherNodes = [\n  { name: \"Unvisited Node\", color: [\"white\"] },\n  { name: \"Visited Node\", color: [\"#51CFE3\", \"#C573FE\"] },\n  { name: \"Shortest Path Node\", color: [\"#FCF16A\"] },\n  { name: \"Wall Node\", color: [\"#0C3547\"] },\n];\n\nconst Glossary = ({ algorithm }) => {\n  return (\n    <Container my=\"6\" px={10} maxW=\"100%\">\n      <Flex>\n        {specialNodes.map((el) => (\n          <HStack px={5} key={el.name}>\n            <Image boxSize=\"25px\" src={el.img} />\n            <Text\n              className={\n                !ALGORITHMS[algorithm].weighted &&\n                el.name === \"Weight Node\" &&\n                \"strike-through\"\n              }\n              as=\"span\"\n              fontSize=\"18px\"\n              fontWeight=\"medium\"\n            >\n              {el.name}\n            </Text>\n          </HStack>\n        ))}\n      </Flex>\n      <Flex mt={3}>\n        {otherNodes.map((node) => (\n          <HStack px={5} key={node.name}>\n            {node.color.map((el) => (\n              <Box\n                key={el}\n                mr={\"5px\"}\n                className=\"node\"\n                bg={el}\n                width=\"25px\"\n                h=\"25px\"\n              ></Box>\n            ))}\n            <Text as=\"span\" fontSize=\"18px\" fontWeight=\"medium\">\n              {node.name}\n            </Text>\n          </HStack>\n        ))}\n      </Flex>\n      <Text color=\"#0C3547\" mt=\"6\" fontSize=\"18px\" textAlign=\"center\">\n        {ALGORITHMS[algorithm].name} is{\" \"}\n        <Text as=\"span\" fontStyle=\"italic\" fontWeight=\"bold\">\n          {ALGORITHMS[algorithm].weighted ? \"weighted\" : \"unweighted\"}{\" \"}\n        </Text>{\" \"}\n        and\n        <Text fontStyle=\"italic\" as=\"span\" fontWeight=\"bold\">\n          {\" \"}\n          {ALGORITHMS[algorithm].shortest ? \"\" : \"does not\"} guarantee\n        </Text>\n        {ALGORITHMS[algorithm].shortest ? \"s\" : \"\"} shortest path\n      </Text>\n    </Container>\n  );\n};\n\nexport default Glossary;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/index\";\nimport { generateGrid } from \"../algorithms/utils\";\nimport { Center, Container, useForceUpdate } from \"@chakra-ui/react\";\nimport Header from \"../../common/components/Header\";\nimport Glossary from \"../../common/components/Glossary\";\nimport { SPEED } from \"../../utils/constants\";\nimport ALGORITHMS from \"../algorithms\";\nimport MAZES from \"../../maze\";\nimport startNodeImg from \"../../images/triangle-right.svg\";\nimport endNodeImg from \"../../images/circle.svg\";\n\nconst ROW = 20;\nconst COL = 50;\n\nconst Visualizer = () => {\n  const forceUpdate = useForceUpdate();\n\n  let [grid, setGrid] = useState([]);\n  let [walls, setWalls] = useState({});\n  let [weights, setWeights] = useState({});\n  let [algorithm, setAlgorithm] = useState(\"Dijkstra\");\n  let [maze, setMaze] = useState(\"Random\");\n  let [speed, setSpeed] = useState(\"Normal\");\n  let [isMousePressed, setIsMousePressed] = useState(false);\n  let [isWPressed, setIsWPressed] = useState(false);\n  let [isStartSelected, setIsStartSelected] = useState(false);\n  let [isEndSelected, setIsEndSelected] = useState(false);\n  let [isGridDirty, setIsGridDirty] = useState(false);\n  let [start, setStart] = useState({ x: 10, y: 15 });\n  let [end, setEnd] = useState({ x: 10, y: 30 });\n  let [animating, setAnimating] = useState(false);\n\n  useEffect(() => {\n    setGrid(generateGrid(ROW, COL, start, end));\n  }, []);\n\n  // wall constructing\n  const handleMouseDown = (row, col, event) => {\n    if (animating) return;\n    // when mouse is being pressed\n    setIsMousePressed(true);\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n  const handleMouseUp = () => {\n    if (animating) return;\n    // when release the mouse\n    setIsMousePressed(false);\n  };\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleWDown);\n    return () => document.removeEventListener(\"keydown\", handleWDown);\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener(\"keyup\", handleWUp);\n    return () => document.removeEventListener(\"keyup\", handleWUp);\n  }, []);\n\n  const handleWDown = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(true);\n  };\n\n  const handleWUp = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(false);\n  };\n\n  const handleMouseEnter = (row, col, event) => {\n    if (animating) return;\n    // when cursor hover the node\n    // if being press, draw wall.\n    // else do nothing\n    if (!isMousePressed) return;\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n\n  const relocateStart = (row, col) => {\n    if (animating) return;\n    setStart({ x: row, y: col });\n    setIsStartSelected(false);\n  };\n  const relocateEnd = (row, col) => {\n    if (animating) return;\n    setEnd({ x: row, y: col });\n    setIsEndSelected(false);\n  };\n\n  const toggleSelectSpecialNode = (isStart, isEnd) => {\n    if (animating) return;\n    if (isStart) {\n      setIsStartSelected((v) => !v);\n      setIsEndSelected(false);\n    }\n    if (isEnd) {\n      setIsStartSelected(false);\n      setIsEndSelected((v) => !v);\n    }\n  };\n\n  const toggleWall = (row, col) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (isWPressed) return;\n\n    let node = grid[row][col];\n\n    walls[node.name] = !walls[node.name] || undefined;\n\n    forceUpdate();\n  };\n\n  const toggleWeight = (row, col, event) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (!isWPressed) return;\n    if (!ALGORITHMS[algorithm].weighted) return;\n\n    let node = grid[row][col];\n    weights[node.name] = !weights[node.name] || 0;\n    forceUpdate();\n  };\n\n  // const forceUpdate = () => {\n  //   // to force re-render when the grid item property change\n  //   setGridRerenderCount((v) => ++v);\n  // };\n\n  // visualizing\n  const animate = ({ visitedNodes, path, closedNodes }) => {\n    let length = closedNodes.length;\n    setAnimating(true);\n    for (let i = 0; i < length; i++) {\n      const node = closedNodes[i];\n      const isEndNode = node.x === end.x && node.y === end.y;\n      // draw path if reach end node\n      if (isEndNode) {\n        setTimeout(() => {\n          drawPath(path);\n        }, SPEED[speed] * i);\n        break;\n      }\n      // animate the visited nodes\n      setTimeout(() => {\n        // draw visited node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-visited\");\n        // draw visited weight\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-visited\");\n        }\n\n        // show current node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-shortest-path\");\n        setTimeout(() => {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.remove(\"node-shortest-path\");\n        }, 30);\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const drawPath = (path) => {\n    let pathLength = path.length;\n    for (let i = 0; i < pathLength; i++) {\n      let node = path[i];\n\n      setTimeout(() => {\n        if (i === pathLength - 1) {\n          setAnimating(false);\n        }\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-shortest-path\");\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        }\n      }, 30 * i);\n    }\n  };\n\n  const visualize = () => {\n    if (animating) return;\n    let newGrid = grid;\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setIsGridDirty(false);\n      setGrid(newGrid);\n    }\n\n    const result = ALGORITHMS[algorithm].algorithm(\n      newGrid,\n      start,\n      end,\n      walls,\n      weights\n    );\n\n    animate({\n      visitedNodes: result.visitedNodes,\n      path: result.path,\n      closedNodes: result.closedNodes,\n    });\n    setIsGridDirty(true); //* this will force re-render\n  };\n\n  const animateWalls = (wallsOrder, walls) => {\n    let length = wallsOrder.length;\n    for (let i = 0; i < length; i++) {\n      let node = wallsOrder[i];\n      setTimeout(() => {\n        if (i === length - 1) {\n          setAnimating(false);\n          if (maze === \"WeightMaze\") {\n            setWeights(walls);\n          } else {\n            setWalls(walls);\n          }\n        }\n        if (maze === \"WeightMaze\") {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-wall\");\n        }\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const generateMaze = () => {\n    if (animating) return;\n    // dont allow to generate weight maze if algorithm is unweighted\n    if (!ALGORITHMS[algorithm].weighted && maze === \"WeightMaze\") return;\n    let newGrid = grid;\n    setWalls({});\n    setAnimating(true);\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setGrid(newGrid);\n    }\n    const walls = MAZES[maze].algorithm(newGrid, start, end);\n    animateWalls(walls.order, walls.walls);\n  };\n\n  // recalculate path whenever start or end changes\n  useEffect(() => {\n    if (isGridDirty) {\n      setIsGridDirty(false);\n      // const newGrid = generateGrid(ROW, COL, start, end);\n      visualize();\n    }\n  }, [start, end]);\n\n  const resetGrid = () => {\n    if (animating) return;\n    setWalls({});\n    setWeights({});\n    setGrid(generateGrid(ROW, COL, start, end));\n    // clean up grid\n    setIsGridDirty(false);\n    setIsMousePressed(false);\n    setIsStartSelected(false);\n    setIsEndSelected(false);\n    setIsWPressed(false);\n  };\n\n  const isStart = (x, y) => start.x === x && start.y === y;\n  const isEnd = (x, y) => end.x === x && end.y === y;\n\n  const renderGrid = () => {\n    return (\n      <div className=\"grid\" style={{ margin: 0 }}>\n        {grid.map((row, rowIndex) => {\n          return (\n            <div style={{ margin: 0, height: \"25px\" }} key={`row-${rowIndex}`}>\n              {row.map((node, nodeIndex) => {\n                const { x, y, visited, name } = node;\n                let isStart = start.x === x && start.y === y;\n                let isEnd = end.x === x && end.y === y;\n                let isWeight = weights[node.name];\n                let isWall = walls[node.name];\n\n                return (\n                  <Node\n                    key={`row-${rowIndex}-node-${nodeIndex}`}\n                    x={x}\n                    y={y}\n                    start={start}\n                    end={end}\n                    grid={grid}\n                    name={name}\n                    isWeight={isWeight}\n                    isWall={isWall}\n                    isStart={isStart}\n                    isClosed={node.closed}\n                    isEnd={isEnd}\n                    visited={visited}\n                    isGridDirty={isGridDirty}\n                    isMousePressed={isMousePressed}\n                    isStartSelected={isStartSelected}\n                    isEndSelected={isEndSelected}\n                    toggleSpecialNode={toggleSelectSpecialNode}\n                    relocateStart={relocateStart}\n                    relocateEnd={relocateEnd}\n                    handleMouseUp={handleMouseUp}\n                    handleMouseDown={(e) => handleMouseDown(x, y, e)}\n                    handleMouseEnter={(e) => handleMouseEnter(x, y, e)}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n  return (\n    <Container\n      px={0}\n      display=\"flex\"\n      flexDir=\"column\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      maxW=\"100%\"\n      minH=\"100vh\"\n    >\n      <Header\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        maze={maze}\n        setMaze={setMaze}\n        speed={speed}\n        setSpeed={setSpeed}\n        animating={animating}\n        visualize={visualize}\n        generateMaze={generateMaze}\n        clearBoard={resetGrid}\n      />\n\n      <Glossary algorithm={algorithm} />\n\n      <Center\n        cursor={`url(${\n          isStartSelected ? startNodeImg : isEndSelected ? endNodeImg : \"\"\n        }),auto`}\n        my=\"5\"\n      >\n        {renderGrid()}\n      </Center>\n    </Container>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\nimport Visualizer from \"../PathFinding/visualizer/index.js\";\n\nconst App = () => {\n  return (\n    <div>\n      <Visualizer />\n    </div>\n  );\n};\n\nexport default App;\n","// theme.js\n\n// 1. import `extendTheme` function\nimport { extendTheme } from \"@chakra-ui/react\";\n\n// 2. Add your color mode config\nconst config = {\n  initialColorMode: \"light\",\n  useSystemColorMode: false,\n};\n\n// 3. extend the theme\nconst theme = extendTheme({ config });\n\nexport default theme;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./app/App\";\nimport \"./app/App.css\";\nimport { ChakraProvider, ColorModeScript } from \"@chakra-ui/react\";\nimport theme from \"./app/theme\";\n\nconst RootApp = () => {\n  return (\n    <div>\n      <ColorModeScript initialColorMode=\"light\" />\n      <ChakraProvider theme={theme}>\n        <App />\n      </ChakraProvider>\n    </div>\n  );\n};\n\nReactDOM.render(<RootApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}