{"version":3,"sources":["PathFinding/visualizer/Node/index.js","utils/utils.js","PathFinding/algorithms/utils.js","PathFinding/DataStructure/BinaryHeap.js","PathFinding/algorithms/dijkstra.js","PathFinding/algorithms/a-star.js","PathFinding/algorithms/index.js","maze/recursive-division.js","maze/index.js","maze/randomMaze.js","maze/stairCase.js","maze/randomWeight.js","utils/constants.js","common/components/Header.js","images/triangle-right.svg","images/circle.svg","PathFinding/visualizer/index.js","app/App.js","app/theme.js","index.js"],"names":["Node","y","isStart","name","isEnd","isWall","isWeight","x","isClosed","start","end","grid","visited","isGridDirty","isStartSelected","isEndSelected","handleMouseUp","isMousePressed","handleMouseDown","handleMouseEnter","toggleSpecialNode","relocateStart","relocateEnd","ref","createRef","useState","extraClassName","animationClassName","useEffect","current","classList","remove","style","margin","width","height","display","onMouseDown","onMouseUp","onMouseEnter","onClick","id","className","React","memo","prefixNumberWithZero","num","convertXYToName","generateGrid","row","column","weighted","outerArr","xLength","innerArr","push","generateNode","setCosts","value","closed","parent","f","g","h","weight","inputGrid","length","node","this","setCostsToNeighbours","getNeighbourNodes","currentNode","dirs","result","i","dir","direction","Math","abs","xGrid","neighbour","undefined","diagonal","randomInteger","min","max","floor","random","getFinalPath","startNode","cur","reverse","curX","curY","BinaryHeap","getScore","content","bubbleUp","endNode","pop","sinkDown","nodeValue","index","indexOf","rightIndex","leftIndex","rightNode","rightNodeValue","leftNode","leftNodeValue","temp","parentIndex","priorityQueue","manhattan_h","ALGORITHMS","Dijkstra","about","algorithm","walls","weights","openList","visitedList","closedList","numNodes","size","path","console","log","visitedNodes","closedNodes","neighbours","neighboursLength","currentG","reorderNode","Astar","heuristics","wallsOrder","addInnerWalls","minX","maxX","minY","maxY","gate","randomNumber","hole","addHWall","minxX","addVWall","MAZES","Random","rowLength","colLength","randomNum","order","Stair","currentX","currentY","Recursive_Division","startXY","endXY","j","addOuterWalls","ent","entrance","addEntrance","WeightMaze","SPEED","Fast","Normal","Slow","Header","setAlgorithm","maze","setMaze","speed","setSpeed","animating","visualize","generateMaze","clearBoard","maxW","bg","py","color","fontSize","mt","onChange","e","target","defaultValue","colorScheme","Object","keys","map","el","isDisabled","variant","_hover","backgroundColor","Visualizer","forceUpdate","useForceUpdate","setGrid","setWalls","setWeights","setIsMousePressed","isWPressed","setIsWPressed","setIsStartSelected","setIsEndSelected","setIsGridDirty","setStart","setEnd","setAnimating","document","addEventListener","handleWDown","removeEventListener","handleWUp","key","col","toggleSelectSpecialNode","v","toggleWall","toggleWeight","event","drawPath","pathLength","setTimeout","getElementById","add","newGrid","animate","px","flexDir","justifyContent","alignItems","minH","animateWalls","cursor","startNodeImg","endNodeImg","my","rowIndex","nodeIndex","App","theme","extendTheme","config","initialColorMode","useSystemColorMode","RootApp","ReactDOM","render"],"mappings":"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","file":"static/js/main.438a9447.chunk.js","sourcesContent":["import React, { useEffect, createRef, useState } from \"react\";\n\nimport \"./node.css\";\n\nconst Node = ({\n  y,\n  name,\n  isStart,\n  isEnd,\n  isWall,\n  isWeight,\n  isClosed,\n  x,\n  start,\n  end,\n  grid,\n  visited,\n  isGridDirty,\n  isStartSelected,\n  isEndSelected,\n  isMousePressed,\n  handleMouseUp,\n  handleMouseDown,\n  handleMouseEnter,\n  toggleSpecialNode,\n  relocateStart,\n  relocateEnd,\n}) => {\n  const ref = createRef();\n  let [debouncedDirty, setDebouncedDirty] = useState(false);\n\n  let extraClassName = isEnd\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isWeight\n    ? \"node-weight\"\n    : \"\";\n  let [animationClassName, setAnimationClassName] = useState(\"\");\n\n  // useEffect(() => {\n  //   if (!isGridDirty) {\n  //     setAnimationClassName(\"\");\n  //   }\n  //   if (isGridDirty && (isStartPressed || isEndPressed)) {\n  //     if (isInShortest !== undefined) {\n  //       setAnimationClassName(\"node-shortest-path-no-ani\");\n  //       return;\n  //     }\n  //     if (isInVisited !== undefined) {\n  //       setAnimationClassName(\"node-visited-no-ani\");\n  //       return;\n  //     }\n  //     setAnimationClassName(\"\");\n  //   }\n  // }, [isInShortest, isInVisited]);\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.classList.remove(\"node-visited\");\n      ref.current.classList.remove(\"node-visited-no-ani\");\n      ref.current.classList.remove(\"node-shortest-path\");\n      ref.current.classList.remove(\"node-shortest-path-no-ani\");\n      ref.current.classList.remove(\"node-weight-visited\");\n    }\n  }, [start, end, isGridDirty, visited, grid]);\n\n  useEffect(() => {\n    if (!isWall && ref.current) {\n      ref.current.classList.remove(\"node-wall\");\n    }\n  }, [isWall]);\n\n  const onNodeClick = () => {\n    if (isStart || isEnd) {\n      toggleSpecialNode(isStart, isEnd);\n    } else {\n      if (isStartSelected) {\n        relocateStart(x, y);\n      }\n      if (isEndSelected) {\n        relocateEnd(x, y);\n      }\n    }\n  };\n\n  return (\n    <div\n      style={{\n        margin: 0,\n        width: \"25px\",\n        height: \"25px\",\n        display: \"inline-block\",\n      }}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseEnter={handleMouseEnter}\n      onClick={onNodeClick}\n    >\n      <div\n        ref={ref}\n        id={`node-${x}-${y}`}\n        className={`node ${extraClassName} ${animationClassName}`}\n      ></div>\n    </div>\n  );\n};\n\nexport default React.memo(Node);\n","export const prefixNumberWithZero = (num) => {\n  return num < 10 ? `0${num}` : num;\n};\n\nexport const convertXYToName = (x, y) => {\n  return `${prefixNumberWithZero(x)}${prefixNumberWithZero(y)}`;\n};\n\nexport const isStart = (x, y, start) => start.x === x && start.y === y;\nexport const isEnd = (x, y, end) => end.x === x && end.y === y;\n","// normalize 2D array to 2D with nodes returned from normalizeNode\nimport { convertXYToName } from \"../../utils/utils\";\nexport function generateGrid(row, column, start, end, weighted = false) {\n  let outerArr = [];\n\n  for (let x = 0; x < row; x++) {\n    let xLength = column;\n    let innerArr = [];\n    for (let y = 0; y < xLength; y++) {\n      innerArr.push(generateNode(1, x, y, start, end));\n    }\n    outerArr.push(innerArr);\n  }\n  // set weights\n  if (weighted) setCosts(outerArr, weighted);\n\n  return outerArr;\n}\n\nexport function generateNode(value, x, y, start, end) {\n  return {\n    x,\n    y,\n    visited: false,\n    closed: false,\n    value: value,\n    parent: null,\n    f: 0,\n    g: 0,\n    h: 0,\n    name: convertXYToName(x, y),\n    weight: 0,\n  };\n}\n\n// set the costs of all nodes to their respective neighbours\nexport function setCosts(inputGrid, weighted = false) {\n  let length = inputGrid.length;\n  for (let x = 0; x < length; x++) {\n    let xLength = inputGrid[x].length;\n\n    for (let y = 0; y < xLength; y++) {\n      let node = inputGrid[x][y];\n      this.setCostsToNeighbours(inputGrid, node, weighted);\n    }\n  }\n}\n\n// set the cost of a node to their neighbour\n// 1, if not weighted,i.e, uniform movement costs\n// random num between 1 and 5, if weighted\nexport function setCostsToNeighbours(grid, currentNode, weighted = false) {\n  if (currentNode.value === 0) {\n    return;\n  }\n  // get neighbours\n  let neighbours = this.getNeighbourNodes(grid, currentNode);\n  let neighbourLength = neighbours.length;\n  // for each neighbour\n  // if neighbour has [currentNode.name] as key in weights, add [neighbour.name]=that weight to currentNode weights\n  // if not, generate random num and add [neighbour.name]=random num\n  for (let i = 0; i < neighbourLength; i++) {\n    let neighbour = neighbours[i];\n\n    // if not weighted, set uniform movement cost\n    if (!weighted) {\n      currentNode.weights[neighbour.name] = 1;\n    } else {\n      // if weighted\n      let weightToCur = neighbour.weights[currentNode.name];\n      // if weighted and neighbour already has cost\n      if (weightToCur) {\n        currentNode.weights[neighbour.name] = weightToCur;\n      } else {\n        // weighted but neighbour doesnt have cost\n        currentNode.weights[neighbour.name] = this.randomInteger(1, 5);\n      }\n    }\n  }\n}\n\nexport function getNeighbourNodes(grid, currentNode, isWall) {\n  let { x, y } = currentNode;\n  let dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    // [-1, 1],\n    // [1, 1],\n    // [1, -1],\n    // [-1, -1],\n  ];\n  let result = [];\n  // get valid non-wall nodes\n  for (let i = 0; i < dirs.length; i++) {\n    let dir = dirs[i];\n    let direction = Math.abs(dir[0] + dir[1]);\n    let xGrid = grid[x + dir[0]];\n    let neighbour = xGrid ? xGrid[y + dir[1]] : undefined;\n\n    if (neighbour && !isWall) {\n      // if the neighbour is diagonal and unvisited, add extra 0.414\n      if (direction === 2) {\n        neighbour.diagonal = true;\n      }\n      result.push(neighbour);\n    }\n  }\n\n  // if (grid[x - 1] && grid[x - 1][y] && !grid[x - 1][y].isWall) {\n  //   result.push(grid[x - 1][y]);\n  // }\n  // if (grid[x + 1] && grid[x + 1][y] && !grid[x + 1][y].isWall) {\n  //   result.push(grid[x + 1][y]);\n  // }\n  // if (grid[x][y - 1] && grid[x][y - 1] && !grid[x][y - 1].isWall) {\n  //   result.push(grid[x][y - 1]);\n  // }\n  // if (grid[x][y + 1] && grid[x][y + 1] && !grid[x][y + 1].isWall) {\n  //   result.push(grid[x][y + 1]);\n  // }\n  return result;\n}\n\nexport function randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// will normally return []\n// but, i need low time complexity so i return object, cuz it's O(1) for accessing the node by name\n// downside of this is losing insertion order\n// but i mimic the insertion order by adding index property to each node\nexport function getFinalPath(node, grid, start) {\n  let result = [];\n\n  let startNode = grid[start.x][start.y];\n\n  let cur = node;\n  while (cur.parent) {\n    result.push(cur);\n\n    let { x, y } = cur.parent;\n    cur = grid[x][y];\n  }\n  result.push(startNode);\n\n  return result.reverse();\n}\n\nexport function isEnd(currentNode, end) {\n  let { x: curX, y: curY } = currentNode;\n  let { x, y } = end;\n  return curX === x && curY === y;\n}\n\nexport const resetNodeIfDirty = (node, prevVisited, curVisited) => {\n  const { name } = node;\n  //reset if not visited for cur search yet, but visited last search\n  let isInPrev = prevVisited[name] !== undefined;\n  let isInCur = curVisited[name] !== undefined;\n  if ((isInPrev && !isInCur) || (!isInPrev && !isInCur)) {\n    node.g = 0;\n    node.f = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n  return node;\n};\n","// this the modified version of binary heap implementation from eloquent javascript book\n// you can see the original version here: https://eloquentjavascript.net/1st_edition/appendix2.html\n\nexport default class BinaryHeap {\n  constructor(getScore) {\n    this.content = [];\n    // instead of hard-coding getter for node's value, we will receive as an argument\n    //! But whenever we need node's value, we will call this function like getScore(node)\n    //! instead of hard-coding like node.value\n    this.getScore = getScore;\n  }\n  push(node) {\n    // add new element to the end of array\n    this.content.push(node);\n    // let it bubble up\n    this.bubbleUp(this.content.length - 1);\n  }\n  pop() {\n    let result = this.content[0];\n\n    // get last node and replace it with first node\n    let endNode = this.content.pop(); // this is Array.prototype.pop, not this class method pop\n\n    // let it sinkDown\n    if (this.content.length > 0) {\n      this.content[0] = endNode;\n      this.sinkDown(0);\n    }\n\n    return result;\n  }\n\n  getLastItem() {\n    return this.content[this.content.length - 1];\n  }\n\n  remove(node) {\n    let length = this.content.length;\n    let nodeValue = this.getScore(node);\n    // to remove a node, we must find item that's equal to node's value\n    for (let i = 0; i < length; i++) {\n      // continue to next item if node value is not equal to current one\n      if (nodeValue !== this.getScore(this.content[i])) continue;\n\n      // get reference to the last item\n      let endNode = this.content.pop(); // this pop() is Array.prototype.pop\n\n      // if node is the last item, we r done\n      if (i === length - 1) break;\n      // replace the node with the last node\n      this.content[i] = endNode;\n      // let it bubble up or sinkdown to reorder the node and then break out the loop, we r done\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n  size() {\n    return this.content.length;\n  }\n  reorderNode(node) {\n    let index = this.content.indexOf(node);\n    this.bubbleUp(index);\n    this.sinkDown(index);\n  }\n  sinkDown(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n    let length = this.content.length;\n\n    while (true) {\n      let rightIndex = (index + 1) * 2;\n      let leftIndex = rightIndex - 1;\n      let rightNode = this.content[rightIndex];\n      let rightNodeValue = this.getScore(rightNode);\n      let leftNode = this.content[leftIndex];\n      let leftNodeValue = this.getScore(leftNode);\n      let temp = null;\n\n      // if left child exists\n      if (leftIndex < length) {\n        if (leftNodeValue < nodeValue) temp = leftIndex;\n      }\n      // if right child exists\n      if (rightIndex < length) {\n        if (rightNodeValue < (temp === null ? nodeValue : leftNodeValue))\n          temp = rightIndex;\n      }\n      // if temp is null, node is smaller than both of its children\n      if (temp === null) break;\n      // swap\n      this.content[index] = this.content[temp];\n      this.content[temp] = node;\n      index = temp;\n    }\n  }\n\n  bubbleUp(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n\n    // except root node\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      let parent = this.content[parentIndex];\n      // node value is greater than parent value, break out the loop\n      if (nodeValue >= this.getScore(parent)) break;\n      // swap node and it's parent\n      this.content[parentIndex] = node;\n      this.content[index] = parent;\n      index = parentIndex;\n    }\n  }\n}\n","import { isEnd, getFinalPath, getNeighbourNodes } from \"./utils\";\nimport BinaryHeap from \"../DataStructure/BinaryHeap\";\n\n// following implementation is mixed with a little bit of UI logic\n// visitedNodesOrder and shortestNodesOrder are for UI purposes\n// see original impelementation at my repo: https://github.com/Kaung-HtetKyaw/Algorithm-Javascript-Implementation\n// this implementation uses Binary Heap for Priority Queue\nlet priorityQueue = new BinaryHeap((x) => x?.g); // binary heap as priority queue\n\n// will reset the node if the grid is used more than once\nexport default function dijkstra(grid, start, end, walls = {}, weights = {}) {\n  let startNode = grid[start.x][start.y];\n\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n  // push to the queue,  add to visited list\n\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(\n      grid,\n      currentNode,\n      walls[currentNode.name]\n    );\n    let neighboursLength = neighbours.length;\n\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n\n      // for first time visiting or current g is smaller than the previous one\n      if (!visited || currentG < neighbour.g) {\n        neighbour.visited = true;\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.g = currentG;\n\n        if (!visited) {\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n  console.log(\"exhausted\");\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n\n// function addToVisitedList(visitedList, node) {\n//   visitedList[node.name] = { node, order: visitedNodesCount };\n//   visitedNodesCount++;\n// }\n","import BinaryHeap from \"../DataStructure/BinaryHeap\";\nimport { getFinalPath, getNeighbourNodes, isEnd } from \"./utils\";\n\nconst priorityQueue = new BinaryHeap((x) => x?.f);\nexport default function a_star(\n  grid,\n  start,\n  end,\n  walls = {},\n  weights = {},\n  heuristics = manhattan_h\n) {\n  let startNode = grid[start.x][start.y];\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  // push to the queue,  add to visited list\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(\n      grid,\n      currentNode,\n      walls[currentNode.name]\n    );\n    let neighboursLength = neighbours.length;\n    // console.log(\"current: \", { x: currentNode.x, y: currentNode.y });\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n      // for first time visiting, there is no previous g so current g will be the best\n      if (!visited || currentG < neighbour.g) {\n        neighbour.visited = true;\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.h = neighbour.h || heuristics(neighbour, end);\n        neighbour.g = currentG;\n        neighbour.f = neighbour.g + neighbour.h;\n\n        if (!visited) {\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n\n  return { path: [], visitedNodes: visitedList, closedNodes: closedList };\n}\n\nfunction manhattan_h(node, end) {\n  let D = 1;\n  let d1 = Math.abs(node.x - end.x);\n  let d2 = Math.abs(node.y - end.y);\n  return D * (d1 + d2);\n}\n","import dijkstra from \"./dijkstra\";\nimport a_star from \"./a-star\";\n\nconst ALGORITHMS = {\n  Dijkstra: {\n    name: \"Dijkstra\",\n    about: \"blah blah\",\n    algorithm: dijkstra,\n  },\n  Astar: {\n    name: \"A*\",\n    about: \"blah blah\",\n    algorithm: a_star,\n  },\n};\n\nexport default ALGORITHMS;\n","import { isStart, isEnd } from \"../utils/utils\";\n\nlet walls = {};\nlet wallsOrder = [];\nlet width, height;\nlet start, end;\n\nexport default function recursive_division(grid, startXY, endXY) {\n  height = grid.length;\n  width = grid[0].length;\n  start = startXY;\n  end = endXY;\n  addOuterWalls(grid);\n  let ent = addEntrance(grid);\n  addInnerWalls(grid, true, 1, height - 2, 1, width - 2, ent);\n  return { walls, order: wallsOrder };\n}\n\nfunction addOuterWalls(grid) {\n  for (let i = 0; i < height; i++) {\n    if (i == 0 || i == height - 1) {\n      for (let j = 0; j < width; j++) {\n        if (isStart(i, j, start) || isEnd(i, j, end)) return;\n        grid[i][j].isWall = true;\n        walls[grid[i][j].name] = true;\n        wallsOrder.push(grid[i][j]);\n      }\n    } else {\n      if (!isStart(i, 0, start) && !isEnd(i, 0, end)) {\n        grid[i][0].isWall = true;\n        walls[grid[i][0].name] = true;\n        wallsOrder.push(grid[i][0]);\n      }\n\n      if (!isStart(i, width - 1, start) && !isEnd(i, width - 1, end)) {\n        grid[i][width - 1].isWall = true;\n        walls[grid[i][width - 1].name] = true;\n        wallsOrder.push(grid[i][width - 1]);\n      }\n    }\n  }\n}\n\nfunction addEntrance(grid) {\n  let x = randomNumber(1, grid.length - 1);\n  grid[grid.length - 1][x].entrance = true;\n  return x;\n}\n\nfunction addInnerWalls(grid, h, minX, maxX, minY, maxY, gate) {\n  if (h) {\n    if (maxX - minX < 2) {\n      return;\n    }\n\n    let x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n    addHWall(grid, minY, maxY, x);\n\n    addInnerWalls(grid, false, minX, x - 1, minY, maxY, gate);\n    addInnerWalls(grid, false, x + 1, maxX, minY, maxY, gate);\n  } else {\n    if (maxY - minY < 2) {\n      return;\n    }\n\n    let y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n    addVWall(grid, minX, maxX, y);\n\n    addInnerWalls(grid, true, minX, maxX, minY, y - 1, gate);\n    addInnerWalls(grid, true, minX, maxX, y + 1, maxY, gate);\n  }\n}\n\nfunction addHWall(grid, minY, maxY, y) {\n  let hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n\n  for (let i = minY; i <= maxY; i++) {\n    if (isStart(y, i, start) || isEnd(y, i, end)) return;\n    if (i === hole) grid[y][i].isWall = false;\n    else {\n      grid[y][i].isWall = true;\n      walls[grid[y][i].name] = true;\n      wallsOrder.push(grid[y][i]);\n    }\n  }\n}\n\nfunction addVWall(grid, minxX, maxY, x) {\n  let hole = Math.floor(randomNumber(minxX, maxY) / 2) * 2 + 1;\n\n  for (let i = minxX; i <= maxY; i++) {\n    if (isStart(i, x, start) || isEnd(i, x, end)) return;\n    if (i === hole) grid[i][x].isWall = false;\n    else {\n      grid[i][x].isWall = true;\n      walls[grid[i][x].name] = true;\n      wallsOrder.push(grid[i][x]);\n    }\n  }\n}\n\nfunction randomNumber(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import randomMaze from \"./randomMaze\";\nimport recursive_division from \"./recursive-division\";\nimport stairCase from \"./stairCase\";\nimport randomWeightMaze from \"./randomWeight\";\n\nconst MAZES = {\n  Random: {\n    name: \"Basic Random Maze\",\n    algorithm: randomMaze,\n    about: \"blah blah\",\n  },\n  Stair: {\n    algorithm: stairCase,\n    name: \"Simple Stair Pattern\",\n    about: \"blah blah\",\n  },\n  Recursive_Division: {\n    name: \"Recursive Division\",\n    algorithm: recursive_division,\n    about: \"blah blah\",\n  },\n  WeightMaze: {\n    name: \"Basic Weight Maze\",\n    algorithm: randomWeightMaze,\n    about: \"blah blah\",\n  },\n};\n\nexport default MAZES;\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (randomNum) {\n        node.isWall = false;\n      } else {\n        node.isWall = true;\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","import { isStart, isEnd } from \"../utils/utils\";\n\nexport default function stairCase(grid = [[]], start, end) {\n  let height = grid.length;\n\n  let width = grid[0].length;\n  let currentX = grid.length - 1;\n  let currentY = 0;\n  let walls = {};\n  let wallsOrder = [];\n\n  while (currentX > 0 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  while (currentX < height - 2 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX++;\n    currentY++;\n  }\n  while (currentX > 0 && currentY < width - 1) {\n    let currentNode = grid[currentX][currentY];\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  return { walls, order: wallsOrder };\n}\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomWeightMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (!randomNum) {\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","export const SPEED = {\n  Fast: 15,\n  Normal: 25,\n  Slow: 40,\n};\n","import React from \"react\";\nimport {\n  Container,\n  Box,\n  HStack,\n  VStack,\n  Stack,\n  Heading,\n  Select,\n  Button,\n} from \"@chakra-ui/react\";\nimport ALGORITHMS from \"../../PathFinding/algorithms\";\nimport MAZES from \"../../maze\";\nimport { SPEED } from \"../../utils/constants\";\n\nconst Header = ({\n  algorithm = \"Dijkstra\",\n  setAlgorithm,\n  maze = \"Random\",\n  setMaze,\n  speed,\n  setSpeed,\n  animating,\n  visualize,\n  generateMaze,\n  clearBoard,\n}) => {\n  return (\n    <Container maxW=\"100%\" bg=\"#34495E\" py=\"6\">\n      <Box>\n        <Heading color=\"white\" fontSize=\"2xl\">\n          Pathfinding Visualizer\n        </Heading>\n      </Box>\n      <Box mt={3}>\n        <Stack direction={[\"column\", \"column\", \"row\"]}>\n          <HStack>\n            <Box>\n              <Select\n                onChange={(e) => setAlgorithm(e.target.value)}\n                width=\"120px\"\n                defaultValue={algorithm}\n                colorScheme=\"teal\"\n                color=\"white\"\n                fontSize=\"13px\"\n              >\n                {Object.keys(ALGORITHMS).map((el) => (\n                  <option\n                    style={{ color: \"black\", fontSize: \"15px\" }}\n                    key={el}\n                    value={el}\n                  >\n                    {ALGORITHMS[el].name}\n                  </option>\n                ))}\n              </Select>\n            </Box>\n            <Select\n              onChange={(e) => setMaze(e.target.value)}\n              width=\"170px\"\n              defaultValue={maze}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(MAZES).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {MAZES[el].name}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Select\n              onChange={(e) => setSpeed(e.target.value)}\n              width=\"170px\"\n              defaultValue={speed}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(SPEED).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {el}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => visualize()}\n              colorScheme=\"teal\"\n              fontSize=\"sm\"\n            >\n              Visualize {algorithm}\n            </Button>\n            <Button\n              isDisabled={animating}\n              onClick={() => generateMaze()}\n              colorScheme=\"blue\"\n              fontSize=\"sm\"\n            >\n              Generate Maze\n            </Button>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => clearBoard()}\n              fontSize=\"sm\"\n              variant=\"ghost\"\n              color=\"white\"\n              _hover={{\n                color: \"#34495E\",\n                backgroundColor: \"white\",\n              }}\n            >\n              Clear Board\n            </Button>\n          </HStack>\n        </Stack>\n      </Box>\n    </Container>\n  );\n};\n\nexport default Header;\n","export default __webpack_public_path__ + \"static/media/triangle-right.c7b52e1e.svg\";","export default __webpack_public_path__ + \"static/media/circle.a538beda.svg\";","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/index\";\nimport { generateGrid } from \"../algorithms/utils\";\nimport { Center, Container, useForceUpdate } from \"@chakra-ui/react\";\nimport Header from \"../../common/components/Header\";\nimport { SPEED } from \"../../utils/constants\";\nimport ALGORITHMS from \"../algorithms\";\nimport MAZES from \"../../maze\";\nimport startNodeImg from \"../../images/triangle-right.svg\";\nimport endNodeImg from \"../../images/circle.svg\";\n\nconst ROW = 20;\nconst COL = 50;\n\nconst Visualizer = () => {\n  const forceUpdate = useForceUpdate();\n\n  let [grid, setGrid] = useState([]);\n  let [walls, setWalls] = useState({});\n  let [weights, setWeights] = useState({});\n  let [algorithm, setAlgorithm] = useState(\"Dijkstra\");\n  let [maze, setMaze] = useState(\"Random\");\n  let [speed, setSpeed] = useState(\"Normal\");\n  let [isMousePressed, setIsMousePressed] = useState(false);\n  let [isWPressed, setIsWPressed] = useState(false);\n  let [isStartSelected, setIsStartSelected] = useState(false);\n  let [isEndSelected, setIsEndSelected] = useState(false);\n  let [isGridDirty, setIsGridDirty] = useState(false);\n  let [start, setStart] = useState({ x: 10, y: 15 });\n  let [end, setEnd] = useState({ x: 10, y: 30 });\n  let [animating, setAnimating] = useState(false);\n\n  useEffect(() => {\n    setGrid(generateGrid(ROW, COL, start, end));\n  }, []);\n\n  // wall constructing\n  const handleMouseDown = (row, col, event) => {\n    if (animating) return;\n    // when mouse is being pressed\n    setIsMousePressed(true);\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n  const handleMouseUp = () => {\n    if (animating) return;\n    // when release the mouse\n    setIsMousePressed(false);\n  };\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleWDown);\n    return () => document.removeEventListener(\"keydown\", handleWDown);\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener(\"keyup\", handleWUp);\n    return () => document.removeEventListener(\"keyup\", handleWUp);\n  }, []);\n\n  const handleWDown = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(true);\n  };\n\n  const handleWUp = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(false);\n  };\n\n  const handleMouseEnter = (row, col, event) => {\n    if (animating) return;\n    // when cursor hover the node\n    // if being press, draw wall.\n    // else do nothing\n    if (!isMousePressed) return;\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n\n  const relocateStart = (row, col) => {\n    if (animating) return;\n    setStart({ x: row, y: col });\n    setIsStartSelected(false);\n  };\n  const relocateEnd = (row, col) => {\n    if (animating) return;\n    setEnd({ x: row, y: col });\n    setIsEndSelected(false);\n  };\n\n  const toggleSelectSpecialNode = (isStart, isEnd) => {\n    if (animating) return;\n    if (isStart) {\n      setIsStartSelected((v) => !v);\n      setIsEndSelected(false);\n    }\n    if (isEnd) {\n      setIsStartSelected(false);\n      setIsEndSelected((v) => !v);\n    }\n  };\n\n  const toggleWall = (row, col) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (isWPressed) return;\n\n    let node = grid[row][col];\n\n    walls[node.name] = !walls[node.name] || undefined;\n\n    forceUpdate();\n  };\n\n  const toggleWeight = (row, col, event) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (!isWPressed) return;\n\n    let node = grid[row][col];\n    weights[node.name] = !weights[node.name] || 0;\n    forceUpdate();\n  };\n\n  // const forceUpdate = () => {\n  //   // to force re-render when the grid item property change\n  //   setGridRerenderCount((v) => ++v);\n  // };\n\n  // visualizing\n  const animate = ({ visitedNodes, path, closedNodes }) => {\n    let length = closedNodes.length;\n    setAnimating(true);\n    for (let i = 0; i < length; i++) {\n      const node = closedNodes[i];\n      const isEndNode = node.x === end.x && node.y === end.y;\n      // draw path if reach end node\n      if (isEndNode) {\n        setTimeout(() => {\n          drawPath(path);\n        }, SPEED[speed] * i);\n        break;\n      }\n      // animate the visited nodes\n      setTimeout(() => {\n        // draw visited node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-visited\");\n        // draw visited weight\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-visited\");\n        }\n\n        // show current node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-shortest-path\");\n        setTimeout(() => {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.remove(\"node-shortest-path\");\n        }, 30);\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const drawPath = (path) => {\n    let pathLength = path.length;\n    for (let i = 0; i < pathLength; i++) {\n      let node = path[i];\n\n      setTimeout(() => {\n        if (i === pathLength - 1) {\n          setAnimating(false);\n        }\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-shortest-path\");\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        }\n      }, 30 * i);\n    }\n  };\n\n  const visualize = () => {\n    if (animating) return;\n    let newGrid = grid;\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setIsGridDirty(false);\n      setGrid(newGrid);\n    }\n\n    const result = ALGORITHMS[algorithm].algorithm(\n      newGrid,\n      start,\n      end,\n      walls,\n      weights\n    );\n    animate({\n      visitedNodes: result.visitedNodes,\n      path: result.path,\n      closedNodes: result.closedNodes,\n    });\n    setIsGridDirty(true); //* this will force re-render\n  };\n\n  const animateWalls = (wallsOrder, walls) => {\n    let length = wallsOrder.length;\n    for (let i = 0; i < length; i++) {\n      let node = wallsOrder[i];\n      setTimeout(() => {\n        if (i === length - 1) {\n          setAnimating(false);\n          if (maze === \"WeightMaze\") {\n            setWeights(walls);\n          } else {\n            setWalls(walls);\n          }\n        }\n        if (maze === \"WeightMaze\") {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-wall\");\n        }\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const generateMaze = () => {\n    if (animating) return;\n    let newGrid = grid;\n    setWalls({});\n    setAnimating(true);\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setGrid(newGrid);\n    }\n    const walls = MAZES[maze].algorithm(newGrid, start, end);\n    animateWalls(walls.order, walls.walls);\n  };\n\n  // recalculate path whenever start or end changes\n  useEffect(() => {\n    if (isGridDirty) {\n      setIsGridDirty(false);\n      // const newGrid = generateGrid(ROW, COL, start, end);\n      visualize();\n    }\n  }, [start, end]);\n\n  const resetGrid = () => {\n    if (animating) return;\n    setWalls({});\n    setWeights({});\n    setGrid(generateGrid(ROW, COL, start, end));\n    // clean up grid\n    setIsGridDirty(false);\n    setIsMousePressed(false);\n    setIsStartSelected(false);\n    setIsEndSelected(false);\n    setIsWPressed(false);\n  };\n\n  const isStart = (x, y) => start.x === x && start.y === y;\n  const isEnd = (x, y) => end.x === x && end.y === y;\n\n  const renderGrid = () => {\n    return (\n      <div className=\"grid\" style={{ margin: 0 }}>\n        {grid.map((row, rowIndex) => {\n          return (\n            <div style={{ margin: 0, height: \"25px\" }} key={`row-${rowIndex}`}>\n              {row.map((node, nodeIndex) => {\n                const { x, y, visited, name } = node;\n                let isStart = start.x === x && start.y === y;\n                let isEnd = end.x === x && end.y === y;\n                let isWeight = weights[node.name];\n                let isWall = walls[node.name];\n\n                return (\n                  <Node\n                    key={`row-${rowIndex}-node-${nodeIndex}`}\n                    x={x}\n                    y={y}\n                    start={start}\n                    end={end}\n                    grid={grid}\n                    name={name}\n                    isWeight={isWeight}\n                    isWall={isWall}\n                    isStart={isStart}\n                    isClosed={node.closed}\n                    isEnd={isEnd}\n                    visited={visited}\n                    isGridDirty={isGridDirty}\n                    isMousePressed={isMousePressed}\n                    isStartSelected={isStartSelected}\n                    isEndSelected={isEndSelected}\n                    toggleSpecialNode={toggleSelectSpecialNode}\n                    relocateStart={relocateStart}\n                    relocateEnd={relocateEnd}\n                    handleMouseUp={handleMouseUp}\n                    handleMouseDown={(e) => handleMouseDown(x, y, e)}\n                    handleMouseEnter={(e) => handleMouseEnter(x, y, e)}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n  return (\n    <Container\n      px={0}\n      display=\"flex\"\n      flexDir=\"column\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      maxW=\"100%\"\n      minH=\"100vh\"\n    >\n      <Header\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        maze={maze}\n        setMaze={setMaze}\n        speed={speed}\n        setSpeed={setSpeed}\n        animating={animating}\n        visualize={visualize}\n        generateMaze={generateMaze}\n        clearBoard={resetGrid}\n      />\n\n      <Center\n        cursor={`url(${\n          isStartSelected ? startNodeImg : isEndSelected ? endNodeImg : \"\"\n        }),auto`}\n        my=\"5\"\n      >\n        {renderGrid()}\n      </Center>\n    </Container>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\nimport Visualizer from \"../PathFinding/visualizer/index.js\";\n\nconst App = () => {\n  return (\n    <div>\n      <Visualizer />\n    </div>\n  );\n};\n\nexport default App;\n","// theme.js\n\n// 1. import `extendTheme` function\nimport { extendTheme } from \"@chakra-ui/react\";\n\n// 2. Add your color mode config\nconst config = {\n  initialColorMode: \"light\",\n  useSystemColorMode: false,\n};\n\n// 3. extend the theme\nconst theme = extendTheme({ config });\n\nexport default theme;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./app/App\";\nimport \"./app/App.css\";\nimport { ChakraProvider, ColorModeScript } from \"@chakra-ui/react\";\nimport theme from \"./app/theme\";\n\nconst RootApp = () => {\n  return (\n    <div>\n      <ColorModeScript initialColorMode=\"light\" />\n      <ChakraProvider theme={theme}>\n        <App />\n      </ChakraProvider>\n    </div>\n  );\n};\n\nReactDOM.render(<RootApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}