{"version":3,"sources":["PathFinding/visualizer/Node/index.js","utils/utils.js","PathFinding/algorithms/utils.js","PathFinding/DataStructure/BinaryHeap.js","PathFinding/algorithms/dijkstra.js","PathFinding/algorithms/a-star.js","PathFinding/algorithms/heuristics.js","PathFinding/algorithms/GBFS.js","PathFinding/algorithms/index.js","PathFinding/algorithms/BFS.js","PathFinding/algorithms/DFS.js","maze/recursive-division.js","maze/index.js","maze/randomMaze.js","maze/stairCase.js","maze/randomWeight.js","utils/constants.js","Tutorial/index.js","common/components/Header.js","images/triangle-right.svg","images/circle.svg","images/weight.svg","common/components/Glossary.js","PathFinding/visualizer/index.js","app/App.js","app/theme.js","index.js"],"names":["Node","y","isStart","name","isEnd","isWall","isWeight","x","isClosed","start","end","grid","isGridDirty","visited","isStartSelected","isEndSelected","handleMouseUp","isMousePressed","handleMouseDown","handleMouseEnter","toggleSpecialNode","relocateStart","relocateEnd","ref","createRef","extraClassName","useState","animationClassName","useEffect","current","classList","remove","style","margin","width","height","display","onMouseDown","onMouseUp","onMouseEnter","onClick","id","className","React","memo","prefixNumberWithZero","num","convertXYToName","generateGrid","row","column","weighted","outerArr","xLength","innerArr","push","generateNode","setCosts","value","closed","parent","f","g","h","weight","inputGrid","length","node","this","setCostsToNeighbours","getNeighbourNodes","currentNode","walls","isDFS","dirs","result","i","dir","direction","Math","abs","xGrid","neighbour","undefined","diagonal","unshift","randomInteger","min","max","floor","random","getFinalPath","startNode","cur","reverse","curX","curY","BinaryHeap","getScore","content","bubbleUp","endNode","pop","sinkDown","nodeValue","index","indexOf","rightIndex","leftIndex","rightNode","rightNodeValue","leftNode","leftNodeValue","temp","parentIndex","priorityQueue","manhattan_h","ALGORITHMS","Dijkstra","about","algorithm","weights","openList","visitedList","closedList","numNodes","size","path","console","log","visitedNodes","closedNodes","neighbours","neighboursLength","currentG","reorderNode","shortest","Astar","heuristics","pow","BFS","Object","keys","shift","neighbourLength","GBFS","currentH","DFS","wallsOrder","addInnerWalls","minX","maxX","minY","maxY","gate","randomNumber","hole","addHWall","minxX","addVWall","MAZES","Random","rowLength","colLength","randomNum","order","Stair","currentX","currentY","Recursive_Division","startXY","endXY","j","addOuterWalls","ent","entrance","addEntrance","WeightMaze","SPEED","Fast","Normal","Slow","Topic","children","mt","justifyContent","alignItems","transform","as","FaQuestion","Tutorial","isOpen","onClose","onOpen","scrollBehavior","pb","mb","flexDir","color","textAlign","fontSize","maxW","base","lg","fontWeight","values","map","el","bg","my","href","textDecor","_hover","Header","setAlgorithm","maze","setMaze","speed","setSpeed","animating","visualize","generateMaze","bomb","toggleBomb","clearBoard","useDisclosure","defaultIsOpen","py","isDisabled","onChange","e","target","defaultValue","colorScheme","variant","backgroundColor","specialNodes","img","startNodeimg","endNodeImg","weightNodeImg","otherNodes","Glossary","px","boxSize","src","flexDirection","mr","fontStyle","Visualizer","forceUpdate","useForceUpdate","COL","setROW","ROW","setCOL","setGrid","setWalls","setWeights","setIsMousePressed","isWPressed","setIsWPressed","setIsStartSelected","setIsEndSelected","setIsGridDirty","setStart","setEnd","setAnimating","window","innerWidth","percentage","col","round","document","addEventListener","handleWDown","removeEventListener","handleWUp","key","toggleSelectSpecialNode","v","toggleWall","toggleWeight","event","drawPath","pathLength","setTimeout","getElementById","add","newGrid","isEndNode","animatePathFind","minH","animateWalls","cursor","startNodeImg","rowIndex","nodeIndex","App","theme","extendTheme","config","initialColorMode","useSystemColorMode","RootApp","ReactDOM","render"],"mappings":"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","file":"static/js/main.4786fad2.chunk.js","sourcesContent":["import React, { useEffect, createRef, useState } from \"react\";\n\nimport \"./node.css\";\n\nconst Node = ({\n  y,\n  name,\n  isStart,\n  isEnd,\n  isWall,\n  isWeight,\n  isClosed,\n  x,\n  start,\n  end,\n  grid,\n  visited,\n  isGridDirty,\n  isStartSelected,\n  isEndSelected,\n  isMousePressed,\n  handleMouseUp,\n  handleMouseDown,\n  handleMouseEnter,\n  toggleSpecialNode,\n  relocateStart,\n  relocateEnd,\n}) => {\n  const ref = createRef();\n\n  let extraClassName = isEnd\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isWeight\n    ? \"node-weight\"\n    : \"\";\n  let [animationClassName, setAnimationClassName] = useState(\"\");\n\n  // useEffect(() => {\n  //   if (!isGridDirty) {\n  //     setAnimationClassName(\"\");\n  //   }\n  //   if (isGridDirty && (isStartPressed || isEndPressed)) {\n  //     if (isInShortest !== undefined) {\n  //       setAnimationClassName(\"node-shortest-path-no-ani\");\n  //       return;\n  //     }\n  //     if (isInVisited !== undefined) {\n  //       setAnimationClassName(\"node-visited-no-ani\");\n  //       return;\n  //     }\n  //     setAnimationClassName(\"\");\n  //   }\n  // }, [isInShortest, isInVisited]);\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.classList.remove(\"node-visited\");\n      ref.current.classList.remove(\"node-visited-no-ani\");\n      ref.current.classList.remove(\"node-shortest-path\");\n      ref.current.classList.remove(\"node-shortest-path-no-ani\");\n      ref.current.classList.remove(\"node-weight-visited\");\n    }\n  }, [start, end, isGridDirty, grid]);\n\n  useEffect(() => {\n    if (!isWall && ref.current) {\n      ref.current.classList.remove(\"node-wall\");\n    }\n  }, [isWall]);\n\n  const onNodeClick = () => {\n    if (isStart || isEnd) {\n      toggleSpecialNode(isStart, isEnd);\n    } else {\n      if (isStartSelected) {\n        relocateStart(x, y);\n      }\n      if (isEndSelected) {\n        relocateEnd(x, y);\n      }\n    }\n  };\n\n  return (\n    <div\n      style={{\n        margin: 0,\n        width: \"25px\",\n        height: \"25px\",\n        display: \"inline-block\",\n      }}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseEnter={handleMouseEnter}\n      onClick={onNodeClick}\n    >\n      <div\n        ref={ref}\n        id={`node-${x}-${y}`}\n        className={`node ${extraClassName} ${animationClassName}`}\n      ></div>\n    </div>\n  );\n};\n\nexport default React.memo(Node);\n","export const prefixNumberWithZero = (num) => {\n  return num < 10 ? `0${num}` : num;\n};\n\nexport const convertXYToName = (x, y) => {\n  return `${prefixNumberWithZero(x)}${prefixNumberWithZero(y)}`;\n};\n\nexport const isStart = (x, y, start) => start.x === x && start.y === y;\nexport const isEnd = (x, y, end) => end.x === x && end.y === y;\n","// normalize 2D array to 2D with nodes returned from normalizeNode\nimport { convertXYToName } from \"../../utils/utils\";\nexport function generateGrid(row, column, start, end, weighted = false) {\n  let outerArr = [];\n\n  for (let x = 0; x < row; x++) {\n    let xLength = column;\n    let innerArr = [];\n    for (let y = 0; y < xLength; y++) {\n      innerArr.push(generateNode(1, x, y, start, end));\n    }\n    outerArr.push(innerArr);\n  }\n  // set weights\n  if (weighted) setCosts(outerArr, weighted);\n\n  return outerArr;\n}\n\nexport function generateNode(value, x, y, start, end) {\n  return {\n    x,\n    y,\n    visited: false,\n    closed: false,\n    value: value,\n    parent: null,\n    f: 0,\n    g: 0,\n    h: 0,\n    name: convertXYToName(x, y),\n    weight: 0,\n  };\n}\n\n// set the costs of all nodes to their respective neighbours\nexport function setCosts(inputGrid, weighted = false) {\n  let length = inputGrid.length;\n  for (let x = 0; x < length; x++) {\n    let xLength = inputGrid[x].length;\n\n    for (let y = 0; y < xLength; y++) {\n      let node = inputGrid[x][y];\n      this.setCostsToNeighbours(inputGrid, node, weighted);\n    }\n  }\n}\n\n// set the cost of a node to their neighbour\n// 1, if not weighted,i.e, uniform movement costs\n// random num between 1 and 5, if weighted\nexport function setCostsToNeighbours(grid, currentNode, weighted = false) {\n  if (currentNode.value === 0) {\n    return;\n  }\n  // get neighbours\n  let neighbours = this.getNeighbourNodes(grid, currentNode);\n  let neighbourLength = neighbours.length;\n  // for each neighbour\n  // if neighbour has [currentNode.name] as key in weights, add [neighbour.name]=that weight to currentNode weights\n  // if not, generate random num and add [neighbour.name]=random num\n  for (let i = 0; i < neighbourLength; i++) {\n    let neighbour = neighbours[i];\n\n    // if not weighted, set uniform movement cost\n    if (!weighted) {\n      currentNode.weights[neighbour.name] = 1;\n    } else {\n      // if weighted\n      let weightToCur = neighbour.weights[currentNode.name];\n      // if weighted and neighbour already has cost\n      if (weightToCur) {\n        currentNode.weights[neighbour.name] = weightToCur;\n      } else {\n        // weighted but neighbour doesnt have cost\n        currentNode.weights[neighbour.name] = this.randomInteger(1, 5);\n      }\n    }\n  }\n}\n\nexport function getNeighbourNodes(grid, currentNode, walls, isDFS = false) {\n  let { x, y } = currentNode;\n  let dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    // [-1, 1],\n    // [1, 1],\n    // [1, -1],\n    // [-1, -1],\n  ];\n  let result = [];\n  // get valid non-wall nodes\n  for (let i = 0; i < dirs.length; i++) {\n    let dir = dirs[i];\n    let direction = Math.abs(dir[0] + dir[1]);\n    let xGrid = grid[x + dir[0]];\n    let neighbour = xGrid ? xGrid[y + dir[1]] : undefined;\n\n    if (neighbour && !walls[neighbour.name]) {\n      // if the neighbour is diagonal and unvisited, add extra 0.414\n      if (direction === 2) {\n        neighbour.diagonal = true;\n      }\n      if (isDFS) {\n        result.unshift(neighbour);\n      } else {\n        result.push(neighbour);\n      }\n    }\n  }\n\n  // if (grid[x - 1] && grid[x - 1][y] && !grid[x - 1][y].isWall) {\n  //   result.push(grid[x - 1][y]);\n  // }\n  // if (grid[x + 1] && grid[x + 1][y] && !grid[x + 1][y].isWall) {\n  //   result.push(grid[x + 1][y]);\n  // }\n  // if (grid[x][y - 1] && grid[x][y - 1] && !grid[x][y - 1].isWall) {\n  //   result.push(grid[x][y - 1]);\n  // }\n  // if (grid[x][y + 1] && grid[x][y + 1] && !grid[x][y + 1].isWall) {\n  //   result.push(grid[x][y + 1]);\n  // }\n  return result;\n}\n\nexport function randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// will normally return []\n// but, i need low time complexity so i return object, cuz it's O(1) for accessing the node by name\n// downside of this is losing insertion order\n// but i mimic the insertion order by adding index property to each node\nexport function getFinalPath(node, grid, start) {\n  let result = [];\n\n  let startNode = grid[start.x][start.y];\n\n  let cur = node;\n  while (cur.parent) {\n    result.push(cur);\n\n    let { x, y } = cur.parent;\n    cur = grid[x][y];\n  }\n  result.push(startNode);\n\n  return result.reverse();\n}\n\nexport function isEnd(currentNode, end) {\n  let { x: curX, y: curY } = currentNode;\n  let { x, y } = end;\n  return curX === x && curY === y;\n}\n\nexport const resetNodeIfDirty = (node, prevVisited, curVisited) => {\n  const { name } = node;\n  //reset if not visited for cur search yet, but visited last search\n  let isInPrev = prevVisited[name] !== undefined;\n  let isInCur = curVisited[name] !== undefined;\n  if ((isInPrev && !isInCur) || (!isInPrev && !isInCur)) {\n    node.g = 0;\n    node.f = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n  return node;\n};\n","// this the modified version of binary heap implementation from eloquent javascript book\n// you can see the original version here: https://eloquentjavascript.net/1st_edition/appendix2.html\n\nexport default class BinaryHeap {\n  constructor(getScore) {\n    this.content = [];\n    // instead of hard-coding getter for node's value, we will receive as an argument\n    //! But whenever we need node's value, we will call this function like getScore(node)\n    //! instead of hard-coding like node.value\n    this.getScore = getScore;\n  }\n  push(node) {\n    // add new element to the end of array\n    this.content.push(node);\n    // let it bubble up\n    this.bubbleUp(this.content.length - 1);\n  }\n  pop() {\n    let result = this.content[0];\n\n    // get last node and replace it with first node\n    let endNode = this.content.pop(); // this is Array.prototype.pop, not this class method pop\n\n    // let it sinkDown\n    if (this.content.length > 0) {\n      this.content[0] = endNode;\n      this.sinkDown(0);\n    }\n\n    return result;\n  }\n\n  getLastItem() {\n    return this.content[this.content.length - 1];\n  }\n\n  remove(node) {\n    let length = this.content.length;\n    let nodeValue = this.getScore(node);\n    // to remove a node, we must find item that's equal to node's value\n    for (let i = 0; i < length; i++) {\n      // continue to next item if node value is not equal to current one\n      if (nodeValue !== this.getScore(this.content[i])) continue;\n\n      // get reference to the last item\n      let endNode = this.content.pop(); // this pop() is Array.prototype.pop\n\n      // if node is the last item, we r done\n      if (i === length - 1) break;\n      // replace the node with the last node\n      this.content[i] = endNode;\n      // let it bubble up or sinkdown to reorder the node and then break out the loop, we r done\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n  size() {\n    return this.content.length;\n  }\n  reorderNode(node) {\n    let index = this.content.indexOf(node);\n    this.bubbleUp(index);\n    this.sinkDown(index);\n  }\n  sinkDown(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n    let length = this.content.length;\n\n    while (true) {\n      let rightIndex = (index + 1) * 2;\n      let leftIndex = rightIndex - 1;\n      let rightNode = this.content[rightIndex];\n      let rightNodeValue = this.getScore(rightNode);\n      let leftNode = this.content[leftIndex];\n      let leftNodeValue = this.getScore(leftNode);\n      let temp = null;\n\n      // if left child exists\n      if (leftIndex < length) {\n        if (leftNodeValue < nodeValue) temp = leftIndex;\n      }\n      // if right child exists\n      if (rightIndex < length) {\n        if (rightNodeValue < (temp === null ? nodeValue : leftNodeValue))\n          temp = rightIndex;\n      }\n      // if temp is null, node is smaller than both of its children\n      if (temp === null) break;\n      // swap\n      this.content[index] = this.content[temp];\n      this.content[temp] = node;\n      index = temp;\n    }\n  }\n\n  bubbleUp(i) {\n    let index = i;\n    let node = this.content[index];\n    let nodeValue = this.getScore(node);\n\n    // except root node\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      let parent = this.content[parentIndex];\n      // node value is greater than parent value, break out the loop\n      if (nodeValue >= this.getScore(parent)) break;\n      // swap node and it's parent\n      this.content[parentIndex] = node;\n      this.content[index] = parent;\n      index = parentIndex;\n    }\n  }\n}\n","import { isEnd, getFinalPath, getNeighbourNodes } from \"./utils\";\nimport BinaryHeap from \"../DataStructure/BinaryHeap\";\n\n// following implementation is mixed with a little bit of UI logic\n// visitedNodesOrder and shortestNodesOrder are for UI purposes\n// see original impelementation at my repo: https://github.com/Kaung-HtetKyaw/Algorithm-Javascript-Implementation\n// this implementation uses Binary Heap for Priority Queue\nlet priorityQueue = new BinaryHeap((x) => x?.g); // binary heap as priority queue\n\n// will reset the node if the grid is used more than once\nexport default function dijkstra(grid, start, end, walls = {}, weights = {}) {\n  let startNode = grid[start.x][start.y];\n\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n  // push to the queue,  add to visited list\n\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end) || (start.x === end.x && start.y === end.y)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n\n      // for first time visiting or current g is smaller than the previous one\n      if (!visited || currentG < neighbour.g) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.g = currentG;\n\n        if (!visited) {\n          neighbour.visited = true;\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n  console.log(\"exhausted\");\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n\n// function addToVisitedList(visitedList, node) {\n//   visitedList[node.name] = { node, order: visitedNodesCount };\n//   visitedNodesCount++;\n// }\n","import BinaryHeap from \"../DataStructure/BinaryHeap\";\nimport { getFinalPath, getNeighbourNodes, isEnd } from \"./utils\";\n\nconst priorityQueue = new BinaryHeap((x) => x?.f);\nexport default function a_star(\n  grid,\n  start,\n  end,\n  walls = {},\n  weights = {},\n  heuristics = manhattan_h\n) {\n  let startNode = grid[start.x][start.y];\n  let openList = priorityQueue;\n  let visitedList = [];\n  let closedList = [];\n  // push to the queue,  add to visited list\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      const path = getFinalPath(currentNode, grid, start);\n      console.log(\"considered nodes: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    currentNode.closed = true;\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n    // console.log(\"current: \", { x: currentNode.x, y: currentNode.y });\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // cur to neighbour cost from start node\n      let currentG = currentNode.g + (weights[neighbour.name] ? 15 : 1);\n      let visited = neighbour.visited;\n      // for first time visiting, there is no previous g so current g will be the best\n      if (!visited || currentG < neighbour.g) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.h = neighbour.h || Math.pow(heuristics(neighbour, end), 1.1);\n        neighbour.g = currentG;\n        neighbour.f = neighbour.g + neighbour.h;\n\n        if (!visited) {\n          neighbour.visited = true;\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n\n  // return empty array if there is no path\n\n  return { path: [], visitedNodes: visitedList, closedNodes: closedList };\n}\n\nfunction manhattan_h(node, end) {\n  let D = 1;\n  let d1 = Math.abs(node.x - end.x);\n  let d2 = Math.abs(node.y - end.y);\n  return D * (d1 + d2);\n}\n","export function manhattan_h(node, end) {\n  let D = 1;\n  let d1 = Math.abs(node.x - end.x);\n  let d2 = Math.abs(node.y - end.y);\n  return D * (d1 + d2);\n}\n","import { manhattan_h } from \"./heuristics\";\nimport { isEnd, getFinalPath, getNeighbourNodes } from \"./utils\";\nimport BinaryHeap from \"../DataStructure/BinaryHeap\";\n\n// object is used for openList because when removing an item , it's time complexity is O(1)\nlet priorityQueue = new BinaryHeap((x) => x?.h);\nexport default function greedy_best_first_search(\n  grid,\n  start,\n  end,\n  walls,\n  weights,\n  heuristics = manhattan_h\n) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = priorityQueue;\n  openList.push(startNode);\n  startNode.visited = true;\n  visitedList.push(startNode);\n\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (openList.size() > 0) {\n    // get the shortest node from open list\n    let currentNode = openList.pop();\n    closedList.push(currentNode);\n    currentNode.closed = true;\n    numNodes++;\n    // if reach end\n    if (isEnd(currentNode, end)) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return { path, closedNodes: closedList, visitedNodes: visitedList };\n    }\n\n    // get neighbour nodes\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighboursLength = neighbours.length;\n\n    for (let x = 0; x < neighboursLength; x++) {\n      let neighbour = neighbours[x];\n      // continue to next neighbour if closed or wall\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      let currentH =\n        heuristics(neighbour, end) + (weights[neighbour.name] ? 15 : 0);\n      let visited = neighbour.visited;\n\n      // for first time visiting or current g is smaller than the previous one\n      if (!visited || currentH < neighbour.h) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        neighbour.h = currentH;\n\n        if (!visited) {\n          neighbour.visited = true;\n          openList.push(neighbour);\n          visitedList.push(neighbour);\n        } else {\n          // already visited the node, but this time it got smaller g value than the previous one\n          // so we need to reorder the node in priorityQueue\n          openList.reorderNode(neighbour);\n        }\n      }\n    }\n  }\n  // return empty array if there is no path\n  return { path: [], closedNodes: closedList, visitedNodes: visitedList };\n}\n\nfunction getShortestNode(openList) {\n  let shortest = null;\n  for (let node in openList) {\n    let isCurrentShortest =\n      shortest === null || openList[node].h < openList[shortest].h;\n    if (isCurrentShortest) {\n      shortest = node;\n    }\n  }\n  return openList[shortest];\n}\n","import dijkstra from \"./dijkstra\";\nimport a_star from \"./a-star\";\nimport BFS from \"./BFS\";\nimport GBFS from \"./GBFS\";\nimport DFS from \"./DFS\";\n\nconst ALGORITHMS = {\n  Dijkstra: {\n    name: \"Dijkstra\",\n    about:\n      \"is the father of path-finding algorithms and guarantees the shortest path.\",\n    algorithm: dijkstra,\n    weighted: true,\n    shortest: true,\n  },\n  Astar: {\n    name: \"A*\",\n    about:\n      \"is arguably the best path-finding algorithm. It combines the pieces of information that Dijkstras Algorithm uses (favoring vertices that are close to the starting point) and heuristics(estimated distance from the node's current positon to goal). It is faster than Dijkstra and guarantees shortest path. \",\n    algorithm: a_star,\n    weighted: true,\n    shortest: true,\n  },\n  BFS: {\n    name: \"Breadth First Search\",\n    about:\n      \"is a graph traversal algorithm that starts traversing the graph from root node and explores all the neighbouring nodes. It is slower than both Dijkstra and A* but guarantees shortest path. \",\n    algorithm: BFS,\n    weighted: false,\n    shortest: true,\n  },\n  GBFS: {\n    name: \"Greedy Best First Search\",\n    about:\n      \"is like A* but it only uses heuristics to search to find the goal. It is faster than A*, Dijkstra, Breadth First Search but does not guarantee shortest path. \",\n    algorithm: GBFS,\n    weighted: true,\n    shortest: false,\n  },\n  DFS: {\n    name: \"Depth First Search\",\n    about:\n      \" starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. It is slower than all of the above algorithms and does not guarantee shortest path. \",\n    algorithm: DFS,\n    weighted: false,\n    shortest: false,\n  },\n};\n\nexport default ALGORITHMS;\n","import { getFinalPath, getNeighbourNodes } from \"./utils\";\n\nexport default function breadth_first_search(grid, start, end, walls) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = [startNode];\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (Object.keys(openList).length > 0) {\n    // get the first item\n    let currentNode = openList[0];\n    closedList.push(currentNode);\n    numNodes++;\n    // reach end\n    if (currentNode.x === end.x && currentNode.y === end.y) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n    // remove it from list\n    openList.shift();\n\n    currentNode.closed = true;\n\n    let neighbours = getNeighbourNodes(grid, currentNode, walls);\n    let neighbourLength = neighbours.length;\n\n    for (let x = 0; x < neighbourLength; x++) {\n      let neighbour = neighbours[x];\n\n      // if neighbour is already considered or wall, continue to next neighbour\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // if the neighbour is visited very first time\n      if (!neighbour.visited) {\n        neighbour.visited = true;\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        openList.push(neighbour);\n        visitedList.push(neighbour);\n      }\n    }\n  }\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n","import { getFinalPath, getNeighbourNodes } from \"./utils\";\n\nexport default function depth_first_search(grid, start, end, walls) {\n  let startNode = grid[start.x][start.y];\n  let visitedList = [];\n  let closedList = [];\n  let openList = [startNode];\n  startNode.visited = true;\n  visitedList.push(startNode);\n  let numNodes = 0; // num of nodes considered, not really important (for extra information)\n\n  while (Object.keys(openList).length > 0) {\n    // get the first item\n    let currentNode = openList.pop();\n\n    currentNode.closed = true;\n    closedList.push(currentNode);\n\n    currentNode.visited = true;\n    visitedList.push(currentNode);\n\n    numNodes++;\n    // reach end\n    if (currentNode.x === end.x && currentNode.y === end.y) {\n      let path = getFinalPath(currentNode, grid, start);\n      console.log(\"Number of nodes considered: \", numNodes);\n      return {\n        path,\n        visitedNodes: visitedList,\n        closedNodes: closedList,\n      };\n    }\n\n    let neighbours = getNeighbourNodes(grid, currentNode, walls, true);\n    let neighbourLength = neighbours.length;\n\n    for (let x = 0; x < neighbourLength; x++) {\n      let neighbour = neighbours[x];\n\n      // if neighbour is already considered or wall, continue to next neighbour\n      if (neighbour.closed || walls[neighbour.name]) {\n        continue;\n      }\n      // if the neighbour is visited very first time\n      if (!neighbour.visited) {\n        neighbour.parent = { x: currentNode.x, y: currentNode.y };\n        openList.push(neighbour);\n      }\n    }\n  }\n  return {\n    path: [],\n    visitedNodes: visitedList,\n    closedNodes: closedList,\n  };\n}\n","import { isStart, isEnd } from \"../utils/utils\";\n\nlet walls = {};\nlet wallsOrder = [];\nlet width, height;\nlet start, end;\n\nexport default function recursive_division(grid, startXY, endXY) {\n  height = grid.length;\n  width = grid[0].length;\n  start = startXY;\n  end = endXY;\n  addOuterWalls(grid);\n  let ent = addEntrance(grid);\n  addInnerWalls(grid, true, 1, height - 2, 1, width - 2, ent);\n  return { walls, order: wallsOrder };\n}\n\nfunction addOuterWalls(grid) {\n  for (let i = 0; i < height; i++) {\n    if (i == 0 || i == height - 1) {\n      for (let j = 0; j < width; j++) {\n        if (isStart(i, j, start) || isEnd(i, j, end)) continue;\n        grid[i][j].isWall = true;\n        walls[grid[i][j].name] = true;\n        wallsOrder.push(grid[i][j]);\n      }\n    } else {\n      if (!isStart(i, 0, start) && !isEnd(i, 0, end)) {\n        grid[i][0].isWall = true;\n        walls[grid[i][0].name] = true;\n        wallsOrder.push(grid[i][0]);\n      }\n\n      if (!isStart(i, width - 1, start) && !isEnd(i, width - 1, end)) {\n        grid[i][width - 1].isWall = true;\n        walls[grid[i][width - 1].name] = true;\n        wallsOrder.push(grid[i][width - 1]);\n      }\n    }\n  }\n}\n\nfunction addEntrance(grid) {\n  let x = randomNumber(1, grid.length - 1);\n  grid[grid.length - 1][x].entrance = true;\n  return x;\n}\n\nfunction addInnerWalls(grid, h, minX, maxX, minY, maxY, gate) {\n  if (h) {\n    if (maxX - minX < 2) {\n      return;\n    }\n\n    let x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n    addHWall(grid, minY, maxY, x);\n\n    addInnerWalls(grid, false, minX, x - 1, minY, maxY, gate);\n    addInnerWalls(grid, false, x + 1, maxX, minY, maxY, gate);\n  } else {\n    if (maxY - minY < 2) {\n      return;\n    }\n\n    let y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n    addVWall(grid, minX, maxX, y);\n\n    addInnerWalls(grid, true, minX, maxX, minY, y - 1, gate);\n    addInnerWalls(grid, true, minX, maxX, y + 1, maxY, gate);\n  }\n}\n\nfunction addHWall(grid, minY, maxY, y) {\n  let hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n\n  for (let i = minY; i <= maxY; i++) {\n    if (isStart(y, i, start) || isEnd(y, i, end)) return;\n    if (i === hole) grid[y][i].isWall = false;\n    else {\n      grid[y][i].isWall = true;\n      walls[grid[y][i].name] = true;\n      wallsOrder.push(grid[y][i]);\n    }\n  }\n}\n\nfunction addVWall(grid, minxX, maxY, x) {\n  let hole = Math.floor(randomNumber(minxX, maxY) / 2) * 2 + 1;\n\n  for (let i = minxX; i <= maxY; i++) {\n    if (isStart(i, x, start) || isEnd(i, x, end)) return;\n    if (i === hole) grid[i][x].isWall = false;\n    else {\n      grid[i][x].isWall = true;\n      walls[grid[i][x].name] = true;\n      wallsOrder.push(grid[i][x]);\n    }\n  }\n}\n\nfunction randomNumber(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import randomMaze from \"./randomMaze\";\nimport recursive_division from \"./recursive-division\";\nimport stairCase from \"./stairCase\";\nimport randomWeightMaze from \"./randomWeight\";\n\nconst MAZES = {\n  Random: {\n    name: \"Basic Random Maze\",\n    algorithm: randomMaze,\n    about: \"blah blah\",\n  },\n  Stair: {\n    algorithm: stairCase,\n    name: \"Simple Stair Pattern\",\n    about: \"blah blah\",\n  },\n  Recursive_Division: {\n    name: \"Recursive Division\",\n    algorithm: recursive_division,\n    about: \"blah blah\",\n  },\n  WeightMaze: {\n    name: \"Basic Weight Maze\",\n    algorithm: randomWeightMaze,\n    about: \"blah blah\",\n  },\n};\n\nexport default MAZES;\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (randomNum) {\n        node.isWall = false;\n      } else {\n        node.isWall = true;\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","import { isStart, isEnd } from \"../utils/utils\";\n\nexport default function stairCase(grid = [[]], start, end) {\n  let height = grid.length;\n\n  let width = grid[0].length;\n  let currentX = grid.length - 1;\n  let currentY = 0;\n  let walls = {};\n  let wallsOrder = [];\n\n  while (currentX > 0 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  while (currentX < height - 2 && currentY < width) {\n    let currentNode = grid[currentX][currentY];\n\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX++;\n    currentY++;\n  }\n  while (currentX > 0 && currentY < width - 1) {\n    let currentNode = grid[currentX][currentY];\n    if (\n      !isStart(currentX, currentY, start) &&\n      !isEnd(currentX, currentY, end)\n    ) {\n      currentNode.isWall = true;\n      walls[currentNode.name] = true;\n      wallsOrder.push(currentNode);\n    }\n    currentX--;\n    currentY++;\n  }\n  return { walls, order: wallsOrder };\n}\n","import { randomInteger } from \"../PathFinding/algorithms/utils\";\nimport { isStart, isEnd } from \"../utils/utils\";\n\nexport default function randomWeightMaze(grid = [[]], start, end) {\n  let rowLength = grid.length;\n  let walls = {};\n  let wallsOrder = [];\n\n  for (let x = 0; x < rowLength; x++) {\n    let colLength = grid[x].length;\n    for (let y = 0; y < colLength; y++) {\n      let node = grid[x][y];\n\n      if (isStart(x, y, start) || isEnd(x, y, end)) continue;\n      let randomNum = randomInteger(0, 3);\n      if (!randomNum) {\n        walls[node.name] = true;\n        wallsOrder.push(node);\n      }\n    }\n  }\n  return { walls, order: wallsOrder };\n}\n","export const SPEED = {\n  Fast: 15,\n  Normal: 25,\n  Slow: 40,\n};\n","import React from \"react\";\nimport {\n  Modal,\n  ModalOverlay,\n  ModalContent,\n  ModalHeader,\n  ModalCloseButton,\n  ModalBody,\n  Text,\n  Box,\n  HStack,\n  Icon,\n} from \"@chakra-ui/react\";\nimport { FaQuestion } from \"react-icons/fa\";\nimport ALGORITHMS from \"../PathFinding/algorithms/index\";\n\nconst Topic = ({ children }) => {\n  return (\n    <HStack mt={5} justifyContent=\"start\" alignItems=\"start\">\n      <Icon transform=\"rotate(180deg)\" mt={2} as={FaQuestion} />\n      <Box>{children}</Box>\n    </HStack>\n  );\n};\n\nconst Tutorial = ({ isOpen, onOpen, onClose }) => {\n  return (\n    <Modal\n      size=\"full\"\n      scrollBehavior=\"inside\"\n      isOpen={isOpen}\n      onClose={onClose}\n    >\n      <ModalOverlay />\n      <ModalContent\n        pb={5}\n        mb={6}\n        display=\"flex\"\n        flexDir=\"column\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n      >\n        <ModalHeader color=\"#0C3547\" textAlign=\"center\" fontSize=\"3xl\">\n          Welcome to Pathfinding Visualizer\n        </ModalHeader>\n        <ModalCloseButton />\n        <ModalBody display=\"flex\" justifyContent=\"center\" color=\"#0C3547\">\n          <Box maxW={{ base: \"100%\", lg: \"70%\" }}>\n            <Text as=\"h5\" fontSize=\"xl\" textAlign=\"center\">\n              This tutorial will walk you through all features of Pathfind\n              Visualizer\n            </Text>\n            <Topic>\n              <Text fontWeight=\"bold\" fontSize=\"xl\">\n                What is a pathfinding algorithm ?\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                Pathfinding algorithms address the problem of finding a path\n                from a source to a destination avoiding obstacles and minimizing\n                the costs (time, distance, risks, fuel, price, etc.)\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                All pathfinding algorithms are implemented for 2D grid. Movement\n                for a grid to its Top, Right, Bottom, Left neighbours will cost\n                of 1\n              </Text>\n            </Topic>\n            <Topic>\n              <Text fontWeight=\"bold\" fontSize=\"xl\">\n                Which algorithms are included in this application ?\n              </Text>\n              {Object.values(ALGORITHMS).map((el) => (\n                <Text key={el.name} mb={2} as=\"li\" fontSize=\"17px\">\n                  <Text as=\"span\" display=\"inline-block\" fontWeight=\"bold\">\n                    {el.name}\n                  </Text>{\" \"}\n                  <span>({el.weighted ? \"weighted\" : \"unweighted\"}):</span>{\" \"}\n                  <span>{el.about}</span>\n                </Text>\n              ))}\n              <Text mb={2} as=\"li\" fontSize=\"17px\">\n                Note that some algorithms are unweighted, while others are\n                weighted. Unweighted algorithms do not take turns or weight\n                nodes into account, whereas weighted ones do. Additionally, not\n                all algorithms guarantee the shortest path.\n              </Text>\n            </Topic>\n            <Topic>\n              <Text fontWeight=\"bold\" fontSize=\"xl\">\n                How to add walls and weights{\" \"}\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                Click on the grid to add a wall. Click on the grid while\n                pressing{\" \"}\n                <Text as=\"span\" fontWeight=\"bold\">\n                  W\n                </Text>{\" \"}\n                to add a weight\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                You can also generate maze and pattern by selecting from the\n                dropdown and click generate Generate Maze button.\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                Walls are impenetrable, meaning that a path cannot cross through\n                them. Weights, however, are not impassable. They are simply more\n                \"costly\" to move through. In this application, moving through a\n                weight node has a \"cost\" of 15.\n              </Text>\n            </Topic>\n            <Topic>\n              <Text fontWeight=\"bold\" fontSize=\"xl\">\n                How to relocate start and end nodes{\" \"}\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                Just simply click on start or end node and the mouse pointer\n                will change to the icon of node you clicked on (start or end)\n                and then just simpley click on the node you want start/end node\n                to be at.\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                If the grid is dirty ,i.e. there was a previous visualization,\n                relocating start/end node will re-visualize the selected\n                pathfinding algorithm.\n              </Text>\n            </Topic>\n            <Topic>\n              <Text fontWeight=\"bold\" fontSize=\"xl\">\n                Priority Queue{\" \"}\n              </Text>\n              <Text as=\"li\" fontSize=\"17px\">\n                Binary Heap is used as a Priority Queue for Dijkstra, A* and\n                Greedy Best First Search.\n              </Text>\n            </Topic>\n            <Box mt={5} height=\"5px\" bg=\"#0C3547\"></Box>\n            <Box fontWeight=\"bold\">\n              <Text my={5} as=\"h5\" fontSize=\"xl\">\n                This project was inspired by{\" \"}\n                <Text\n                  as=\"a\"\n                  href=\"https://clementmihailescu.github.io/Pathfinding-Visualizer/#\"\n                  textDecor=\"underline\"\n                  _hover={{\n                    color: \"teal\",\n                  }}\n                >\n                  Clement Mihailescu's pathfinding visualizer.\n                </Text>\n              </Text>\n              <Text my={5} as=\"h5\" fontSize=\"xl\">\n                If you want to see the source of this application, you can get\n                it here:{\" \"}\n                <Text\n                  _hover={{\n                    color: \"teal\",\n                  }}\n                  as=\"a\"\n                  href=\"https://github.com/Kaung-HtetKyaw/pathfinding-visualizer\"\n                  textDecor=\"underline\"\n                >\n                  https://github.com/Kaung-HtetKyaw/pathfinding-visualizer\n                </Text>\n              </Text>\n              <Text my={5} as=\"h5\" fontSize=\"xl\">\n                If you want to see the source of the more generic versions of\n                algorithms implemented in this porject, you can get it here:{\" \"}\n                <Text\n                  _hover={{\n                    color: \"teal\",\n                  }}\n                  as=\"a\"\n                  href=\"https://github.com/Kaung-HtetKyaw/Algorithm-Javascript-Implementation\"\n                  textDecor=\"underline\"\n                >\n                  https://github.com/Kaung-HtetKyaw/Algorithm-Javascript-Implementation\n                </Text>\n              </Text>\n              <Text my={5} as=\"h5\" fontSize=\"xl\">\n                If anyone reading this knows of anything that could make it\n                better, please let me know.\n              </Text>\n            </Box>\n          </Box>\n        </ModalBody>\n\n        {/* <ModalFooter display=\"flex\" justifyContent=\"space-between\">\n          <Button colorScheme=\"teal\" mr={3} onClick={onClose}>\n            Skip Tutorial\n          </Button>\n          <Button variant=\"ghost\">Secondary Action</Button>\n        </ModalFooter> */}\n      </ModalContent>\n    </Modal>\n  );\n};\n\nexport default Tutorial;\n","import React from \"react\";\nimport {\n  Container,\n  Box,\n  HStack,\n  Stack,\n  Heading,\n  Select,\n  Button,\n  useDisclosure,\n} from \"@chakra-ui/react\";\nimport ALGORITHMS from \"../../PathFinding/algorithms\";\nimport MAZES from \"../../maze\";\nimport { SPEED } from \"../../utils/constants\";\nimport Tutorial from \"../../Tutorial/index\";\n\nconst Header = ({\n  algorithm = \"Dijkstra\",\n  setAlgorithm,\n  maze = \"Random\",\n  setMaze,\n  speed,\n  setSpeed,\n  animating,\n  visualize,\n  generateMaze,\n  bomb,\n  toggleBomb,\n  clearBoard,\n}) => {\n  const { onOpen, onClose, isOpen } = useDisclosure({ defaultIsOpen: true });\n  return (\n    <Container maxW=\"100%\" bg=\"#34495E\" py=\"6\">\n      <Box>\n        <Heading color=\"white\" fontSize=\"2xl\">\n          Pathfinding Visualizer\n        </Heading>\n      </Box>\n      <Box mt={3}>\n        <Stack direction={[\"column\", \"column\", \"row\"]}>\n          <HStack>\n            <Box>\n              <Select\n                isDisabled={animating}\n                onChange={(e) => setAlgorithm(e.target.value)}\n                width=\"120px\"\n                defaultValue={algorithm}\n                colorScheme=\"teal\"\n                color=\"white\"\n                fontSize=\"13px\"\n              >\n                {Object.keys(ALGORITHMS).map((el) => (\n                  <option\n                    style={{ color: \"black\", fontSize: \"15px\" }}\n                    key={el}\n                    value={el}\n                  >\n                    {ALGORITHMS[el].name}\n                  </option>\n                ))}\n              </Select>\n            </Box>\n            <Select\n              isDisabled={animating}\n              onChange={(e) => setMaze(e.target.value)}\n              width=\"170px\"\n              defaultValue={maze}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(MAZES).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {MAZES[el].name}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Select\n              isDisabled={animating}\n              onChange={(e) => setSpeed(e.target.value)}\n              width=\"170px\"\n              defaultValue={speed}\n              colorScheme=\"teal\"\n              color=\"white\"\n              fontSize=\"13px\"\n            >\n              {Object.keys(SPEED).map((el) => (\n                <option\n                  style={{ color: \"black\", fontSize: \"15px\" }}\n                  key={el}\n                  value={el}\n                >\n                  {el}\n                </option>\n              ))}\n            </Select>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => visualize()}\n              colorScheme=\"teal\"\n              fontSize=\"sm\"\n            >\n              Visualize {ALGORITHMS[algorithm].name}\n            </Button>\n            <Button\n              isDisabled={animating}\n              onClick={() => generateMaze()}\n              colorScheme=\"blue\"\n              fontSize=\"sm\"\n            >\n              Generate Maze\n            </Button>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => toggleBomb()}\n              colorScheme=\"blue\"\n              fontSize=\"sm\"\n            >\n              {bomb ? \"Remove\" : \"Add\"} Bomb\n            </Button>\n            <Button\n              isDisabled={animating}\n              onClick={() => clearBoard()}\n              fontSize=\"sm\"\n              variant=\"ghost\"\n              color=\"white\"\n              _hover={{\n                color: \"#34495E\",\n                backgroundColor: \"white\",\n              }}\n            >\n              Clear Board\n            </Button>\n          </HStack>\n          <HStack>\n            <Button\n              isDisabled={animating}\n              onClick={() => onOpen()}\n              fontSize=\"sm\"\n              variant=\"ghost\"\n              color=\"white\"\n              _hover={{\n                color: \"#34495E\",\n                backgroundColor: \"white\",\n              }}\n            >\n              Show Tutorial\n            </Button>\n            <Tutorial onClose={onClose} onOpen={onOpen} isOpen={isOpen} />\n          </HStack>\n        </Stack>\n      </Box>\n    </Container>\n  );\n};\n\nexport default Header;\n","export default __webpack_public_path__ + \"static/media/triangle-right.c7b52e1e.svg\";","export default __webpack_public_path__ + \"static/media/circle.a538beda.svg\";","export default __webpack_public_path__ + \"static/media/weight.2e4bdffd.svg\";","import React from \"react\";\nimport { Container, Image, Box, HStack, Flex, Text } from \"@chakra-ui/react\";\nimport startNodeimg from \"../../images/triangle-right.svg\";\nimport endNodeImg from \"../../images/circle.svg\";\nimport weightNodeImg from \"../../images/weight.svg\";\nimport ALGORITHMS from \"../../PathFinding/algorithms\";\n\nconst specialNodes = [\n  { name: \"Start Node\", img: startNodeimg },\n  { name: \"End Node\", img: endNodeImg },\n  { name: \"Weight Node\", img: weightNodeImg },\n];\n\nconst otherNodes = [\n  { name: \"Unvisited Node\", color: [\"white\"] },\n  { name: \"Visited Node\", color: [\"#51CFE3\", \"#C573FE\"] },\n  { name: \"Shortest Path Node\", color: [\"#FCF16A\"] },\n  { name: \"Wall Node\", color: [\"#0C3547\"] },\n];\n\nconst Glossary = ({ algorithm }) => {\n  return (\n    <Container my=\"6\" px={10} maxW=\"100%\">\n      <Flex>\n        {specialNodes.map((el) => (\n          <HStack px={5} key={el.name}>\n            <Image boxSize=\"25px\" src={el.img} />\n            <Text\n              className={\n                !ALGORITHMS[algorithm].weighted &&\n                el.name === \"Weight Node\" &&\n                \"strike-through\"\n              }\n              as=\"span\"\n              fontSize=\"18px\"\n              fontWeight=\"medium\"\n            >\n              {el.name}\n            </Text>\n          </HStack>\n        ))}\n      </Flex>\n      <Flex flexDirection={{ base: \"column\", lg: \"row\" }} mt={3}>\n        {otherNodes.map((node) => (\n          <HStack px={5} py={{ base: \"3\", lg: \"0\" }} key={node.name}>\n            {node.color.map((el) => (\n              <Box\n                key={el}\n                mr={\"5px\"}\n                className=\"node\"\n                bg={el}\n                width=\"25px\"\n                h=\"25px\"\n              ></Box>\n            ))}\n            <Text as=\"span\" fontSize=\"18px\" fontWeight=\"medium\">\n              {node.name}\n            </Text>\n          </HStack>\n        ))}\n      </Flex>\n      <Text color=\"#0C3547\" mt=\"6\" fontSize=\"18px\" textAlign=\"center\">\n        {ALGORITHMS[algorithm].name} is{\" \"}\n        <Text as=\"span\" fontStyle=\"italic\" fontWeight=\"bold\">\n          {ALGORITHMS[algorithm].weighted ? \"weighted\" : \"unweighted\"}{\" \"}\n        </Text>{\" \"}\n        and\n        <Text fontStyle=\"italic\" as=\"span\" fontWeight=\"bold\">\n          {\" \"}\n          {ALGORITHMS[algorithm].shortest ? \"\" : \"does not\"} guarantee\n          {ALGORITHMS[algorithm].shortest ? \"s\" : \"\"}\n        </Text>{\" \"}\n        shortest path\n      </Text>\n    </Container>\n  );\n};\n\nexport default Glossary;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/index\";\nimport { generateGrid, randomInteger } from \"../algorithms/utils\";\nimport { Center, Container, useForceUpdate } from \"@chakra-ui/react\";\nimport Header from \"../../common/components/Header\";\nimport Glossary from \"../../common/components/Glossary\";\nimport { SPEED } from \"../../utils/constants\";\nimport ALGORITHMS from \"../algorithms\";\nimport MAZES from \"../../maze\";\nimport startNodeImg from \"../../images/triangle-right.svg\";\nimport endNodeImg from \"../../images/circle.svg\";\n\nconst Visualizer = () => {\n  const forceUpdate = useForceUpdate();\n\n  let [COL, setROW] = useState(0);\n  let [ROW, setCOL] = useState(0);\n  let [grid, setGrid] = useState([]);\n  let [walls, setWalls] = useState({});\n  let [weights, setWeights] = useState({});\n  let [algorithm, setAlgorithm] = useState(\"Dijkstra\");\n  let [maze, setMaze] = useState(\"Random\");\n  let [speed, setSpeed] = useState(\"Normal\");\n  let [isMousePressed, setIsMousePressed] = useState(false);\n  let [isWPressed, setIsWPressed] = useState(false);\n  let [isStartSelected, setIsStartSelected] = useState(false);\n  let [isEndSelected, setIsEndSelected] = useState(false);\n  let [isGridDirty, setIsGridDirty] = useState(false);\n  let [start, setStart] = useState({ x: 0, y: 0 });\n  let [end, setEnd] = useState({ x: 5, y: 5 });\n  let [animating, setAnimating] = useState(false);\n\n  useEffect(() => {\n    let width = window.innerWidth;\n    let percentage = width <= 400 ? 0.8 : 0.9;\n    let col = Math.round((width * percentage) / 25);\n    let row = 20;\n    let startNode = {\n      x: randomInteger(0, row / 2),\n      y: randomInteger(0, col / 2),\n    };\n    let endNode = {\n      x: randomInteger(0, row - 1),\n      y: randomInteger(0, col - 1),\n    };\n\n    setROW(row);\n    setCOL(col);\n    setStart(startNode);\n    setEnd(endNode);\n    setGrid(generateGrid(row, col, startNode, endNode));\n  }, []);\n\n  // wall constructing\n  const handleMouseDown = (row, col, event) => {\n    if (animating) return;\n    // when mouse is being pressed\n    setIsMousePressed(true);\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n  const handleMouseUp = () => {\n    if (animating) return;\n    // when release the mouse\n    setIsMousePressed(false);\n  };\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleWDown);\n    return () => document.removeEventListener(\"keydown\", handleWDown);\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener(\"keyup\", handleWUp);\n    return () => document.removeEventListener(\"keyup\", handleWUp);\n  }, []);\n\n  const handleWDown = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(true);\n  };\n\n  const handleWUp = (e) => {\n    if (animating) return;\n    if (e.key !== \"w\") return;\n    setIsWPressed(false);\n  };\n\n  const handleMouseEnter = (row, col, event) => {\n    if (animating) return;\n    // when cursor hover the node\n    // if being press, draw wall.\n    // else do nothing\n    if (!isMousePressed) return;\n    toggleWall(row, col);\n    toggleWeight(row, col, event);\n  };\n\n  const relocateStart = (row, col) => {\n    if (animating) return;\n    setStart({ x: row, y: col });\n    setIsStartSelected(false);\n  };\n  const relocateEnd = (row, col) => {\n    if (animating) return;\n    setEnd({ x: row, y: col });\n    setIsEndSelected(false);\n  };\n\n  const toggleSelectSpecialNode = (isStart, isEnd) => {\n    if (animating) return;\n    if (isStart) {\n      setIsStartSelected((v) => !v);\n      setIsEndSelected(false);\n    }\n    if (isEnd) {\n      setIsStartSelected(false);\n      setIsEndSelected((v) => !v);\n    }\n  };\n\n  const toggleWall = (row, col) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (isWPressed) return;\n\n    let node = grid[row][col];\n\n    walls[node.name] = !walls[node.name] || undefined;\n\n    forceUpdate();\n  };\n\n  const toggleWeight = (row, col, event) => {\n    // dont let us draw the wall, when grid is dirty\n    if (isGridDirty) return;\n    if (animating) return;\n    if (isStartSelected || isEndSelected) return;\n    if (isStart(row, col) || isEnd(row, col)) return;\n    if (!isWPressed) return;\n    if (!ALGORITHMS[algorithm].weighted) return;\n\n    let node = grid[row][col];\n    weights[node.name] = !weights[node.name] || 0;\n    forceUpdate();\n  };\n\n  // visualizing\n  const animatePathFind = ({ visitedNodes, path, closedNodes }) => {\n    let length = closedNodes.length;\n    setAnimating(true);\n    for (let i = 0; i < length; i++) {\n      const node = closedNodes[i];\n      const isEndNode = node.x === end.x && node.y === end.y;\n      // if reach end but there is no shortest path\n      if (i === length - 1) {\n        setAnimating(false);\n      }\n      // draw path if reach end node\n      if (isEndNode) {\n        setTimeout(() => {\n          drawPath(path);\n        }, SPEED[speed] * i);\n        break;\n      }\n      // animate the visited nodes\n      setTimeout(() => {\n        // draw visited node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-visited\");\n        // draw visited weight\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-visited\");\n        }\n\n        // show current node\n        document\n          .getElementById(`node-${node.x}-${node.y}`)\n          .classList.add(\"node-shortest-path\");\n        setTimeout(() => {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.remove(\"node-shortest-path\");\n        }, 30);\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const drawPath = (path) => {\n    let pathLength = path.length;\n    for (let i = 0; i < pathLength; i++) {\n      let node = path[i];\n\n      setTimeout(() => {\n        if (i === pathLength - 1) {\n          setAnimating(false);\n        }\n        if (weights[node.name]) {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight-shortest-path\");\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-shortest-path\");\n        }\n      }, 30 * i);\n    }\n  };\n\n  const visualize = () => {\n    if (animating) return;\n    let newGrid = grid;\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setIsGridDirty(false);\n      setGrid(newGrid);\n    }\n\n    const result = ALGORITHMS[algorithm].algorithm(\n      newGrid,\n      start,\n      end,\n      walls,\n      weights\n    );\n\n    animatePathFind({\n      visitedNodes: result.visitedNodes,\n      path: result.path,\n      closedNodes: result.closedNodes,\n    });\n    setIsGridDirty(true); //* this will force re-render\n  };\n\n  const animateWalls = (wallsOrder, walls) => {\n    let length = wallsOrder.length;\n    for (let i = 0; i < length; i++) {\n      let node = wallsOrder[i];\n      setTimeout(() => {\n        if (i === length - 1) {\n          setAnimating(false);\n          if (maze === \"WeightMaze\") {\n            setWeights(walls);\n          } else {\n            setWalls(walls);\n          }\n        }\n        if (maze === \"WeightMaze\") {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-weight\");\n        } else {\n          document\n            .getElementById(`node-${node.x}-${node.y}`)\n            .classList.add(\"node-wall\");\n        }\n      }, SPEED[speed] * i);\n    }\n  };\n\n  const generateMaze = () => {\n    if (animating) return;\n    // dont allow to generate weight maze if algorithm is unweighted\n    if (!ALGORITHMS[algorithm].weighted && maze === \"WeightMaze\") return;\n    let newGrid = grid;\n    setWalls({});\n    setAnimating(true);\n    if (isGridDirty) {\n      newGrid = generateGrid(ROW, COL, start, end);\n      setGrid(newGrid);\n    }\n    const walls = MAZES[maze].algorithm(newGrid, start, end);\n    animateWalls(walls.order, walls.walls);\n  };\n\n  // recalculate path whenever start or end changes\n  useEffect(() => {\n    if (isGridDirty) {\n      setIsGridDirty(false);\n      // const newGrid = generateGrid(ROW, COL, start, end);\n      visualize();\n    }\n  }, [start, end]);\n\n  const resetGrid = () => {\n    if (animating) return;\n    setWalls({});\n    setWeights({});\n    setGrid(generateGrid(ROW, COL, start, end));\n    // clean up grid\n    setIsGridDirty(false);\n    setIsMousePressed(false);\n    setIsStartSelected(false);\n    setIsEndSelected(false);\n    setIsWPressed(false);\n  };\n\n  const isStart = (x, y) => start.x === x && start.y === y;\n  const isEnd = (x, y) => end.x === x && end.y === y;\n\n  const renderGrid = () => {\n    return (\n      <div className=\"grid\" style={{ margin: 0 }}>\n        {grid.map((row, rowIndex) => {\n          return (\n            <div style={{ margin: 0, height: \"25px\" }} key={`row-${rowIndex}`}>\n              {row.map((node, nodeIndex) => {\n                const { x, y, visited, name } = node;\n                let isStart = start.x === x && start.y === y;\n                let isEnd = end.x === x && end.y === y;\n                let isWeight = weights[node.name];\n                let isWall = walls[node.name];\n\n                return (\n                  <Node\n                    key={`row-${rowIndex}-node-${nodeIndex}`}\n                    x={x}\n                    y={y}\n                    start={start}\n                    end={end}\n                    grid={grid}\n                    name={name}\n                    isWeight={isWeight}\n                    isWall={isWall}\n                    isStart={isStart}\n                    isClosed={node.closed}\n                    isEnd={isEnd}\n                    visited={visited}\n                    isGridDirty={isGridDirty}\n                    isMousePressed={isMousePressed}\n                    isStartSelected={isStartSelected}\n                    isEndSelected={isEndSelected}\n                    toggleSpecialNode={toggleSelectSpecialNode}\n                    relocateStart={relocateStart}\n                    relocateEnd={relocateEnd}\n                    handleMouseUp={handleMouseUp}\n                    handleMouseDown={(e) => handleMouseDown(x, y, e)}\n                    handleMouseEnter={(e) => handleMouseEnter(x, y, e)}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n  return (\n    <Container\n      px={0}\n      display=\"flex\"\n      flexDir=\"column\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      maxW=\"100%\"\n      minH=\"100vh\"\n    >\n      <Header\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        maze={maze}\n        setMaze={setMaze}\n        speed={speed}\n        setSpeed={setSpeed}\n        animating={animating}\n        visualize={visualize}\n        generateMaze={generateMaze}\n        clearBoard={resetGrid}\n      />\n\n      <Glossary algorithm={algorithm} />\n\n      <Center\n        cursor={`url(${\n          isStartSelected ? startNodeImg : isEndSelected ? endNodeImg : \"\"\n        }),auto`}\n        my=\"5\"\n      >\n        {renderGrid()}\n      </Center>\n    </Container>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\nimport Visualizer from \"../PathFinding/visualizer/index.js\";\n\nconst App = () => {\n  return <Visualizer />;\n};\n\nexport default App;\n","// theme.js\n\n// 1. import `extendTheme` function\nimport { extendTheme } from \"@chakra-ui/react\";\n\n// 2. Add your color mode config\nconst config = {\n  initialColorMode: \"light\",\n  useSystemColorMode: false,\n};\n\n// 3. extend the theme\nconst theme = extendTheme({ config });\n\nexport default theme;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./app/App\";\nimport \"./app/App.css\";\nimport { ChakraProvider, ColorModeScript } from \"@chakra-ui/react\";\nimport theme from \"./app/theme\";\n\nconst RootApp = () => {\n  return (\n    <div>\n      <ColorModeScript initialColorMode=\"light\" />\n      <ChakraProvider theme={theme}>\n        <App />\n      </ChakraProvider>\n    </div>\n  );\n};\n\nReactDOM.render(<RootApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}